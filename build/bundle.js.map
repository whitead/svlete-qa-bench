{"version":3,"file":"bundle.js","sources":["../../node_modules/svelte/internal/index.mjs","../../node_modules/svelte/transition/index.mjs","../../src/Answer.svelte","../../src/AnswerGroup.svelte","../../src/data.js","../../src/App.svelte","../../src/main.js"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\nfunction is_promise(value) {\n    return !!value && (typeof value === 'object' || typeof value === 'function') && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nlet src_url_equal_anchor;\nfunction src_url_equal(element_src, url) {\n    if (!src_url_equal_anchor) {\n        src_url_equal_anchor = document.createElement('a');\n    }\n    src_url_equal_anchor.href = url;\n    return element_src === src_url_equal_anchor.href;\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\nfunction get_all_dirty_from_scope($$scope) {\n    if ($$scope.ctx.length > 32) {\n        const dirty = [];\n        const length = $$scope.ctx.length / 32;\n        for (let i = 0; i < length; i++) {\n            dirty[i] = -1;\n        }\n        return dirty;\n    }\n    return -1;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\nfunction split_css_unit(value) {\n    const split = typeof value === 'string' && value.match(/^\\s*(-?[\\d.]+)([^\\s]*)\\s*$/);\n    return split ? [parseFloat(split[1]), split[2] || 'px'] : [value, 'px'];\n}\nconst contenteditable_truthy_values = ['', true, 1, 'true', 'contenteditable'];\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\nfunction start_hydrating() {\n    is_hydrating = true;\n}\nfunction end_hydrating() {\n    is_hydrating = false;\n}\nfunction upper_bound(low, high, key, value) {\n    // Return first index of value larger than input value in the range [low, high)\n    while (low < high) {\n        const mid = low + ((high - low) >> 1);\n        if (key(mid) <= value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction init_hydrate(target) {\n    if (target.hydrate_init)\n        return;\n    target.hydrate_init = true;\n    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n    let children = target.childNodes;\n    // If target is <head>, there may be children without claim_order\n    if (target.nodeName === 'HEAD') {\n        const myChildren = [];\n        for (let i = 0; i < children.length; i++) {\n            const node = children[i];\n            if (node.claim_order !== undefined) {\n                myChildren.push(node);\n            }\n        }\n        children = myChildren;\n    }\n    /*\n    * Reorder claimed children optimally.\n    * We can reorder claimed children optimally by finding the longest subsequence of\n    * nodes that are already claimed in order and only moving the rest. The longest\n    * subsequence of nodes that are claimed in order can be found by\n    * computing the longest increasing subsequence of .claim_order values.\n    *\n    * This algorithm is optimal in generating the least amount of reorder operations\n    * possible.\n    *\n    * Proof:\n    * We know that, given a set of reordering operations, the nodes that do not move\n    * always form an increasing subsequence, since they do not move among each other\n    * meaning that they must be already ordered among each other. Thus, the maximal\n    * set of nodes that do not move form a longest increasing subsequence.\n    */\n    // Compute longest increasing subsequence\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n    const m = new Int32Array(children.length + 1);\n    // Predecessor indices + 1\n    const p = new Int32Array(children.length);\n    m[0] = -1;\n    let longest = 0;\n    for (let i = 0; i < children.length; i++) {\n        const current = children[i].claim_order;\n        // Find the largest subsequence length such that it ends in a value less than our current value\n        // upper_bound returns first greater value, so we subtract one\n        // with fast path for when we are on the current longest subsequence\n        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n        p[i] = m[seqLen] + 1;\n        const newLen = seqLen + 1;\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n        m[newLen] = i;\n        longest = Math.max(newLen, longest);\n    }\n    // The longest increasing subsequence of nodes (initially reversed)\n    const lis = [];\n    // The rest of the nodes, nodes that will be moved\n    const toMove = [];\n    let last = children.length - 1;\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n        lis.push(children[cur - 1]);\n        for (; last >= cur; last--) {\n            toMove.push(children[last]);\n        }\n        last--;\n    }\n    for (; last >= 0; last--) {\n        toMove.push(children[last]);\n    }\n    lis.reverse();\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\n    // Finally, we move the nodes\n    for (let i = 0, j = 0; i < toMove.length; i++) {\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n            j++;\n        }\n        const anchor = j < lis.length ? lis[j] : null;\n        target.insertBefore(toMove[i], anchor);\n    }\n}\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n    const append_styles_to = get_root_for_style(target);\n    if (!append_styles_to.getElementById(style_sheet_id)) {\n        const style = element('style');\n        style.id = style_sheet_id;\n        style.textContent = styles;\n        append_stylesheet(append_styles_to, style);\n    }\n}\nfunction get_root_for_style(node) {\n    if (!node)\n        return document;\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n    if (root && root.host) {\n        return root;\n    }\n    return node.ownerDocument;\n}\nfunction append_empty_stylesheet(node) {\n    const style_element = element('style');\n    append_stylesheet(get_root_for_style(node), style_element);\n    return style_element.sheet;\n}\nfunction append_stylesheet(node, style) {\n    append(node.head || node, style);\n    return style.sheet;\n}\nfunction append_hydration(target, node) {\n    if (is_hydrating) {\n        init_hydrate(target);\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentNode !== target))) {\n            target.actual_end_child = target.firstChild;\n        }\n        // Skip nodes of undefined ordering\n        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n            target.actual_end_child = target.actual_end_child.nextSibling;\n        }\n        if (node !== target.actual_end_child) {\n            // We only insert if the ordering of this node should be modified or the parent node is not target\n            if (node.claim_order !== undefined || node.parentNode !== target) {\n                target.insertBefore(node, target.actual_end_child);\n            }\n        }\n        else {\n            target.actual_end_child = node.nextSibling;\n        }\n    }\n    else if (node.parentNode !== target || node.nextSibling !== null) {\n        target.appendChild(node);\n    }\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction insert_hydration(target, node, anchor) {\n    if (is_hydrating && !anchor) {\n        append_hydration(target, node);\n    }\n    else if (node.parentNode !== target || node.nextSibling != anchor) {\n        target.insertBefore(node, anchor || null);\n    }\n}\nfunction detach(node) {\n    if (node.parentNode) {\n        node.parentNode.removeChild(node);\n    }\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction comment(content) {\n    return document.createComment(content);\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_immediate_propagation(fn) {\n    return function (event) {\n        event.stopImmediatePropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction trusted(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.isTrusted)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data_map(node, data_map) {\n    Object.keys(data_map).forEach((key) => {\n        set_custom_element_data(node, key, data_map[key]);\n    });\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction set_dynamic_element_data(tag) {\n    return (/-/.test(tag)) ? set_custom_element_data_map : set_attributes;\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction init_binding_group(group) {\n    let _inputs;\n    return {\n        /* push */ p(...inputs) {\n            _inputs = inputs;\n            _inputs.forEach(input => group.push(input));\n        },\n        /* remove */ r() {\n            _inputs.forEach(input => group.splice(group.indexOf(input), 1));\n        }\n    };\n}\nfunction init_binding_group_dynamic(group, indexes) {\n    let _group = get_binding_group(group);\n    let _inputs;\n    function get_binding_group(group) {\n        for (let i = 0; i < indexes.length; i++) {\n            group = group[indexes[i]] = group[indexes[i]] || [];\n        }\n        return group;\n    }\n    function push() {\n        _inputs.forEach(input => _group.push(input));\n    }\n    function remove() {\n        _inputs.forEach(input => _group.splice(_group.indexOf(input), 1));\n    }\n    return {\n        /* update */ u(new_indexes) {\n            indexes = new_indexes;\n            const new_group = get_binding_group(group);\n            if (new_group !== _group) {\n                remove();\n                _group = new_group;\n                push();\n            }\n        },\n        /* push */ p(...inputs) {\n            _inputs = inputs;\n            push();\n        },\n        /* remove */ r: remove\n    };\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction init_claim_info(nodes) {\n    if (nodes.claim_info === undefined) {\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\n    }\n}\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n    init_claim_info(nodes);\n    const resultNode = (() => {\n        // We first try to find an element after the previous one\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                return node;\n            }\n        }\n        // Otherwise, we try to find one before\n        // We iterate in reverse so that we don't go too far back\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                else if (replacement === undefined) {\n                    // Since we spliced before the last_index, we decrease it\n                    nodes.claim_info.last_index--;\n                }\n                return node;\n            }\n        }\n        // If we can't find any matching node, we create a new one\n        return createNode();\n    })();\n    resultNode.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n    return resultNode;\n}\nfunction claim_element_base(nodes, name, attributes, create_element) {\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n        const remove = [];\n        for (let j = 0; j < node.attributes.length; j++) {\n            const attribute = node.attributes[j];\n            if (!attributes[attribute.name]) {\n                remove.push(attribute.name);\n            }\n        }\n        remove.forEach(v => node.removeAttribute(v));\n        return undefined;\n    }, () => create_element(name));\n}\nfunction claim_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, element);\n}\nfunction claim_svg_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, svg_element);\n}\nfunction claim_text(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n        const dataStr = '' + data;\n        if (node.data.startsWith(dataStr)) {\n            if (node.data.length !== dataStr.length) {\n                return node.splitText(dataStr.length);\n            }\n        }\n        else {\n            node.data = dataStr;\n        }\n    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n    );\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction claim_comment(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 8, (node) => {\n        node.data = '' + data;\n        return undefined;\n    }, () => comment(data), true);\n}\nfunction find_comment(nodes, text, start) {\n    for (let i = start; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n            return i;\n        }\n    }\n    return nodes.length;\n}\nfunction claim_html_tag(nodes, is_svg) {\n    // find html opening tag\n    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);\n    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);\n    if (start_index === end_index) {\n        return new HtmlTagHydration(undefined, is_svg);\n    }\n    init_claim_info(nodes);\n    const html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);\n    detach(html_tag_nodes[0]);\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\n    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n    for (const n of claimed_nodes) {\n        n.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n    }\n    return new HtmlTagHydration(claimed_nodes, is_svg);\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.data === data)\n        return;\n    text.data = data;\n}\nfunction set_data_contenteditable(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    text.data = data;\n}\nfunction set_data_maybe_contenteditable(text, data, attr_value) {\n    if (~contenteditable_truthy_values.indexOf(attr_value)) {\n        set_data_contenteditable(text, data);\n    }\n    else {\n        set_data(text, data);\n    }\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    if (value === null) {\n        node.style.removeProperty(key);\n    }\n    else {\n        node.style.setProperty(key, value, important ? 'important' : '');\n    }\n}\nfunction select_option(select, value, mounting) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n    if (!mounting || value !== undefined) {\n        select.selectedIndex = -1; // no option should be selected\n    }\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked');\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n            // make sure an initial resize event is fired _after_ the iframe is loaded (which is asynchronous)\n            // see https://github.com/sveltejs/svelte/issues/4233\n            fn();\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, bubbles, cancelable, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nfunction head_selector(nodeId, head) {\n    const result = [];\n    let started = 0;\n    for (const node of head.childNodes) {\n        if (node.nodeType === 8 /* comment node */) {\n            const comment = node.textContent.trim();\n            if (comment === `HEAD_${nodeId}_END`) {\n                started -= 1;\n                result.push(node);\n            }\n            else if (comment === `HEAD_${nodeId}_START`) {\n                started += 1;\n                result.push(node);\n            }\n        }\n        else if (started > 0) {\n            result.push(node);\n        }\n    }\n    return result;\n}\nclass HtmlTag {\n    constructor(is_svg = false) {\n        this.is_svg = false;\n        this.is_svg = is_svg;\n        this.e = this.n = null;\n    }\n    c(html) {\n        this.h(html);\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            if (this.is_svg)\n                this.e = svg_element(target.nodeName);\n            /** #7364  target for <template> may be provided as #document-fragment(11) */\n            else\n                this.e = element((target.nodeType === 11 ? 'TEMPLATE' : target.nodeName));\n            this.t = target.tagName !== 'TEMPLATE' ? target : target.content;\n            this.c(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nclass HtmlTagHydration extends HtmlTag {\n    constructor(claimed_nodes, is_svg = false) {\n        super(is_svg);\n        this.e = this.n = null;\n        this.l = claimed_nodes;\n    }\n    c(html) {\n        if (this.l) {\n            this.n = this.l;\n        }\n        else {\n            super.c(html);\n        }\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert_hydration(this.t, this.n[i], anchor);\n        }\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\nfunction construct_svelte_component(component, props) {\n    return new component(props);\n}\n\n// we need to store the information for multiple documents because a Svelte application could also contain iframes\n// https://github.com/sveltejs/svelte/issues/3624\nconst managed_styles = new Map();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_style_information(doc, node) {\n    const info = { stylesheet: append_empty_stylesheet(node), rules: {} };\n    managed_styles.set(doc, info);\n    return info;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = get_root_for_style(node);\n    const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);\n    if (!rules[name]) {\n        rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        managed_styles.forEach(info => {\n            const { ownerNode } = info.stylesheet;\n            // there is no ownerNode if it runs on jsdom.\n            if (ownerNode)\n                detach(ownerNode);\n        });\n        managed_styles.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\n/**\n * Schedules a callback to run immediately before the component is updated after any state change.\n *\n * The first time the callback runs will be before the initial `onMount`\n *\n * https://svelte.dev/docs#run-time-svelte-beforeupdate\n */\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\n/**\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n * it can be called from an external module).\n *\n * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).\n *\n * https://svelte.dev/docs#run-time-svelte-onmount\n */\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\n/**\n * Schedules a callback to run immediately after the component has been updated.\n *\n * The first time the callback runs will be after the initial `onMount`\n */\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * https://svelte.dev/docs#run-time-svelte-ondestroy\n */\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\n/**\n * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\n *\n * Component events created with `createEventDispatcher` create a\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\n * property and can contain any type of data.\n *\n * https://svelte.dev/docs#run-time-svelte-createeventdispatcher\n */\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail, { cancelable = false } = {}) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail, { cancelable });\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n            return !event.defaultPrevented;\n        }\n        return true;\n    };\n}\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-setcontext\n */\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n    return context;\n}\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-getcontext\n */\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * https://svelte.dev/docs#run-time-svelte-getallcontexts\n */\nfunction getAllContexts() {\n    return get_current_component().$$.context;\n}\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-hascontext\n */\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        // @ts-ignore\n        callbacks.slice().forEach(fn => fn.call(this, event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nlet render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = /* @__PURE__ */ Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\nlet flushidx = 0; // Do *not* move this inside the flush() function\nfunction flush() {\n    // Do not reenter flush while dirty components are updated, as this can\n    // result in an infinite loop. Instead, let the inner flush handle it.\n    // Reentrancy is ok afterwards for bindings etc.\n    if (flushidx !== 0) {\n        return;\n    }\n    const saved_component = current_component;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        try {\n            while (flushidx < dirty_components.length) {\n                const component = dirty_components[flushidx];\n                flushidx++;\n                set_current_component(component);\n                update(component.$$);\n            }\n        }\n        catch (e) {\n            // reset dirty state to not end up in a deadlocked state and then rethrow\n            dirty_components.length = 0;\n            flushidx = 0;\n            throw e;\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        flushidx = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    seen_callbacks.clear();\n    set_current_component(saved_component);\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n/**\n * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.\n */\nfunction flush_render_callbacks(fns) {\n    const filtered = [];\n    const targets = [];\n    render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n    targets.forEach((c) => c());\n    render_callbacks = filtered;\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n    else if (callback) {\n        callback();\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    const options = { direction: 'in' };\n    let config = fn(node, params, options);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            started = true;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config(options);\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    const options = { direction: 'out' };\n    let config = fn(node, params, options);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config(options);\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    const options = { direction: 'both' };\n    let config = fn(node, params, options);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = (program.b - t);\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro  we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro  needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config(options);\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\nfunction update_await_block_branch(info, ctx, dirty) {\n    const child_ctx = ctx.slice();\n    const { resolved } = info;\n    if (info.current === info.then) {\n        child_ctx[info.value] = resolved;\n    }\n    if (info.current === info.catch) {\n        child_ctx[info.error] = resolved;\n    }\n    info.block.p(child_ctx, dirty);\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    const updates = [];\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            // defer updates until all the DOM shuffling is done\n            updates.push(() => block.p(child_ctx, dirty));\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    run_all(updates);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\nconst _boolean_attributes = [\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'inert',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n];\n/**\n * List of HTML boolean attributes (e.g. `<input disabled>`).\n * Source: https://html.spec.whatwg.org/multipage/indices.html\n */\nconst boolean_attributes = new Set([..._boolean_attributes]);\n\n/** regex of all html void element names */\nconst void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;\nfunction is_void(name) {\n    return void_element_names.test(name) || name.toLowerCase() === '!doctype';\n}\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, attrs_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (attrs_to_add) {\n        const classes_to_add = attrs_to_add.classes;\n        const styles_to_add = attrs_to_add.styles;\n        if (classes_to_add) {\n            if (attributes.class == null) {\n                attributes.class = classes_to_add;\n            }\n            else {\n                attributes.class += ' ' + classes_to_add;\n            }\n        }\n        if (styles_to_add) {\n            if (attributes.style == null) {\n                attributes.style = style_object_to_string(styles_to_add);\n            }\n            else {\n                attributes.style = style_object_to_string(merge_ssr_styles(attributes.style, styles_to_add));\n            }\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${value}\"`;\n        }\n    });\n    return str;\n}\nfunction merge_ssr_styles(style_attribute, style_directive) {\n    const style_object = {};\n    for (const individual_style of style_attribute.split(';')) {\n        const colon_index = individual_style.indexOf(':');\n        const name = individual_style.slice(0, colon_index).trim();\n        const value = individual_style.slice(colon_index + 1).trim();\n        if (!name)\n            continue;\n        style_object[name] = value;\n    }\n    for (const name in style_directive) {\n        const value = style_directive[name];\n        if (value) {\n            style_object[name] = value;\n        }\n        else {\n            delete style_object[name];\n        }\n    }\n    return style_object;\n}\nconst ATTR_REGEX = /[&\"]/g;\nconst CONTENT_REGEX = /[&<]/g;\n/**\n * Note: this method is performance sensitive and has been optimized\n * https://github.com/sveltejs/svelte/pull/5701\n */\nfunction escape(value, is_attr = false) {\n    const str = String(value);\n    const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;\n    pattern.lastIndex = 0;\n    let escaped = '';\n    let last = 0;\n    while (pattern.test(str)) {\n        const i = pattern.lastIndex - 1;\n        const ch = str[i];\n        escaped += str.substring(last, i) + (ch === '&' ? '&amp;' : (ch === '\"' ? '&quot;' : '&lt;'));\n        last = i + 1;\n    }\n    return escaped + str.substring(last);\n}\nfunction escape_attribute_value(value) {\n    // keep booleans, null, and undefined for the sake of `spread`\n    const should_escape = typeof value === 'string' || (value && typeof value === 'object');\n    return should_escape ? escape(value, true) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules. Otherwise you may need to fix a <${name}>.`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    const assignment = (boolean && value === true) ? '' : `=\"${escape(value, true)}\"`;\n    return ` ${name}${assignment}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\nfunction style_object_to_string(style_object) {\n    return Object.keys(style_object)\n        .filter(key => style_object[key])\n        .map(key => `${key}: ${escape_attribute_value(style_object[key])};`)\n        .join(' ');\n}\nfunction add_styles(style_object) {\n    const styles = style_object_to_string(style_object);\n    return styles ? ` style=\"${styles}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n            // if the component was destroyed immediately\n            // it will update the `$$.on_destroy` reference to `null`.\n            // the destructured on_destroy may still reference to the old array\n            if (component.$$.on_destroy) {\n                component.$$.on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        flush_render_callbacks($$.after_update);\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: [],\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false,\n        root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            start_hydrating();\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        end_hydrating();\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            if (!is_function(callback)) {\n                return noop;\n            }\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        if (!is_function(callback)) {\n            return noop;\n        }\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.58.0' }, detail), { bubbles: true }));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction append_hydration_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append_hydration(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction insert_hydration_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert_hydration(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation, has_stop_immediate_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    if (has_stop_immediate_propagation)\n        modifiers.push('stopImmediatePropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.data === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction set_data_contenteditable_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction set_data_maybe_contenteditable_dev(text, data, attr_value) {\n    if (~contenteditable_truthy_values.indexOf(attr_value)) {\n        set_data_contenteditable_dev(text, data);\n    }\n    else {\n        set_data_dev(text, data);\n    }\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\nfunction validate_dynamic_element(tag) {\n    const is_string = typeof tag === 'string';\n    if (tag && !is_string) {\n        throw new Error('<svelte:element> expects \"this\" attribute to be a string.');\n    }\n}\nfunction validate_void_dynamic_element(tag) {\n    if (tag && is_void(tag)) {\n        console.warn(`<svelte:element this=\"${tag}\"> is self-closing and cannot have content.`);\n    }\n}\nfunction construct_svelte_component_dev(component, props) {\n    const error_message = 'this={...} of <svelte:component> should specify a Svelte component.';\n    try {\n        const instance = new component(props);\n        if (!instance.$$ || !instance.$set || !instance.$on || !instance.$destroy) {\n            throw new Error(error_message);\n        }\n        return instance;\n    }\n    catch (err) {\n        const { message } = err;\n        if (typeof message === 'string' && message.indexOf('is not a constructor') !== -1) {\n            throw new Error(error_message);\n        }\n        else {\n            throw err;\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to separate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, HtmlTagHydration, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_styles, add_transform, afterUpdate, append, append_dev, append_empty_stylesheet, append_hydration, append_hydration_dev, append_styles, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_comment, claim_component, claim_element, claim_html_tag, claim_space, claim_svg_element, claim_text, clear_loops, comment, component_subscribe, compute_rest_props, compute_slots, construct_svelte_component, construct_svelte_component_dev, contenteditable_truthy_values, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, end_hydrating, escape, escape_attribute_value, escape_object, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, flush_render_callbacks, getAllContexts, getContext, get_all_dirty_from_scope, get_binding_group_value, get_current_component, get_custom_elements_slots, get_root_for_style, get_slot_changes, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, head_selector, identity, init, init_binding_group, init_binding_group_dynamic, insert, insert_dev, insert_hydration, insert_hydration_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, is_void, listen, listen_dev, loop, loop_guard, merge_ssr_styles, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_custom_element_data_map, set_data, set_data_contenteditable, set_data_contenteditable_dev, set_data_dev, set_data_maybe_contenteditable, set_data_maybe_contenteditable_dev, set_dynamic_element_data, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, split_css_unit, spread, src_url_equal, start_hydrating, stop_immediate_propagation, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, trusted, update_await_block_branch, update_keyed_each, update_slot, update_slot_base, validate_component, validate_dynamic_element, validate_each_argument, validate_each_keys, validate_slots, validate_store, validate_void_dynamic_element, xlink_attr };\n","import { cubicInOut, linear, cubicOut } from '../easing/index.mjs';\nimport { split_css_unit, is_function, assign } from '../internal/index.mjs';\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\n\nfunction blur(node, { delay = 0, duration = 400, easing = cubicInOut, amount = 5, opacity = 0 } = {}) {\n    const style = getComputedStyle(node);\n    const target_opacity = +style.opacity;\n    const f = style.filter === 'none' ? '' : style.filter;\n    const od = target_opacity * (1 - opacity);\n    const [value, unit] = split_css_unit(amount);\n    return {\n        delay,\n        duration,\n        easing,\n        css: (_t, u) => `opacity: ${target_opacity - (od * u)}; filter: ${f} blur(${u * value}${unit});`\n    };\n}\nfunction fade(node, { delay = 0, duration = 400, easing = linear } = {}) {\n    const o = +getComputedStyle(node).opacity;\n    return {\n        delay,\n        duration,\n        easing,\n        css: t => `opacity: ${t * o}`\n    };\n}\nfunction fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 } = {}) {\n    const style = getComputedStyle(node);\n    const target_opacity = +style.opacity;\n    const transform = style.transform === 'none' ? '' : style.transform;\n    const od = target_opacity * (1 - opacity);\n    const [xValue, xUnit] = split_css_unit(x);\n    const [yValue, yUnit] = split_css_unit(y);\n    return {\n        delay,\n        duration,\n        easing,\n        css: (t, u) => `\n\t\t\ttransform: ${transform} translate(${(1 - t) * xValue}${xUnit}, ${(1 - t) * yValue}${yUnit});\n\t\t\topacity: ${target_opacity - (od * u)}`\n    };\n}\nfunction slide(node, { delay = 0, duration = 400, easing = cubicOut, axis = 'y' } = {}) {\n    const style = getComputedStyle(node);\n    const opacity = +style.opacity;\n    const primary_property = axis === 'y' ? 'height' : 'width';\n    const primary_property_value = parseFloat(style[primary_property]);\n    const secondary_properties = axis === 'y' ? ['top', 'bottom'] : ['left', 'right'];\n    const capitalized_secondary_properties = secondary_properties.map((e) => `${e[0].toUpperCase()}${e.slice(1)}`);\n    const padding_start_value = parseFloat(style[`padding${capitalized_secondary_properties[0]}`]);\n    const padding_end_value = parseFloat(style[`padding${capitalized_secondary_properties[1]}`]);\n    const margin_start_value = parseFloat(style[`margin${capitalized_secondary_properties[0]}`]);\n    const margin_end_value = parseFloat(style[`margin${capitalized_secondary_properties[1]}`]);\n    const border_width_start_value = parseFloat(style[`border${capitalized_secondary_properties[0]}Width`]);\n    const border_width_end_value = parseFloat(style[`border${capitalized_secondary_properties[1]}Width`]);\n    return {\n        delay,\n        duration,\n        easing,\n        css: t => 'overflow: hidden;' +\n            `opacity: ${Math.min(t * 20, 1) * opacity};` +\n            `${primary_property}: ${t * primary_property_value}px;` +\n            `padding-${secondary_properties[0]}: ${t * padding_start_value}px;` +\n            `padding-${secondary_properties[1]}: ${t * padding_end_value}px;` +\n            `margin-${secondary_properties[0]}: ${t * margin_start_value}px;` +\n            `margin-${secondary_properties[1]}: ${t * margin_end_value}px;` +\n            `border-${secondary_properties[0]}-width: ${t * border_width_start_value}px;` +\n            `border-${secondary_properties[1]}-width: ${t * border_width_end_value}px;`\n    };\n}\nfunction scale(node, { delay = 0, duration = 400, easing = cubicOut, start = 0, opacity = 0 } = {}) {\n    const style = getComputedStyle(node);\n    const target_opacity = +style.opacity;\n    const transform = style.transform === 'none' ? '' : style.transform;\n    const sd = 1 - start;\n    const od = target_opacity * (1 - opacity);\n    return {\n        delay,\n        duration,\n        easing,\n        css: (_t, u) => `\n\t\t\ttransform: ${transform} scale(${1 - (sd * u)});\n\t\t\topacity: ${target_opacity - (od * u)}\n\t\t`\n    };\n}\nfunction draw(node, { delay = 0, speed, duration, easing = cubicInOut } = {}) {\n    let len = node.getTotalLength();\n    const style = getComputedStyle(node);\n    if (style.strokeLinecap !== 'butt') {\n        len += parseInt(style.strokeWidth);\n    }\n    if (duration === undefined) {\n        if (speed === undefined) {\n            duration = 800;\n        }\n        else {\n            duration = len / speed;\n        }\n    }\n    else if (typeof duration === 'function') {\n        duration = duration(len);\n    }\n    return {\n        delay,\n        duration,\n        easing,\n        css: (_, u) => `\n\t\t\tstroke-dasharray: ${len};\n\t\t\tstroke-dashoffset: ${u * len};\n\t\t`\n    };\n}\nfunction crossfade(_a) {\n    var { fallback } = _a, defaults = __rest(_a, [\"fallback\"]);\n    const to_receive = new Map();\n    const to_send = new Map();\n    function crossfade(from_node, node, params) {\n        const { delay = 0, duration = d => Math.sqrt(d) * 30, easing = cubicOut } = assign(assign({}, defaults), params);\n        const from = from_node.getBoundingClientRect();\n        const to = node.getBoundingClientRect();\n        const dx = from.left - to.left;\n        const dy = from.top - to.top;\n        const dw = from.width / to.width;\n        const dh = from.height / to.height;\n        const d = Math.sqrt(dx * dx + dy * dy);\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        const opacity = +style.opacity;\n        return {\n            delay,\n            duration: is_function(duration) ? duration(d) : duration,\n            easing,\n            css: (t, u) => `\n\t\t\t\topacity: ${t * opacity};\n\t\t\t\ttransform-origin: top left;\n\t\t\t\ttransform: ${transform} translate(${u * dx}px,${u * dy}px) scale(${t + (1 - t) * dw}, ${t + (1 - t) * dh});\n\t\t\t`\n        };\n    }\n    function transition(items, counterparts, intro) {\n        return (node, params) => {\n            items.set(params.key, node);\n            return () => {\n                if (counterparts.has(params.key)) {\n                    const other_node = counterparts.get(params.key);\n                    counterparts.delete(params.key);\n                    return crossfade(other_node, node, params);\n                }\n                // if the node is disappearing altogether\n                // (i.e. wasn't claimed by the other list)\n                // then we need to supply an outro\n                items.delete(params.key);\n                return fallback && fallback(node, params, intro);\n            };\n        };\n    }\n    return [\n        transition(to_send, to_receive, false),\n        transition(to_receive, to_send, true)\n    ];\n}\n\nexport { blur, crossfade, draw, fade, fly, scale, slide };\n","<script>\n    import { fade } from \"svelte/transition\";\n    export let question = \"\";\n    export let answer = \"\";\n    export let date = \"\";\n    export let model = \"\";\n    export let sources = [];\n\n    let showSources = false;\n\n    function toggleSources() {\n        showSources = !showSources;\n    }\n\n    \n</script>\n\n<main>\n    <!-- <p class=\"question\">{question}</p> -->\n    <div class=\"details\">\n        <table>\n            <tr>\n                <td>model:</td>\n                <td class=\"model\">{model}</td>\n            </tr>\n            <tr>\n                <td>date:</td>\n                <td>{date}</td>\n            </tr>\n        </table>\n        <p class=\"answer\">\n            {answer}\n        </p>\n        <button on:click={toggleSources}>\n            {#if showSources}\n                hide sources\n            {:else}\n                show sources\n            {/if}\n        </button>\n        {#if showSources}\n            <div transition:fade>\n                {#each sources as reference}\n                    <p class=\"reference\">[{reference.key}] {reference.text}</p>\n                {/each}\n            </div>\n        {/if}\n    </div>\n</main>\n\n<style>\n    main {\n        background-color: antiquewhite;\n        padding: 20px;\n        max-width: 800px;\n        flex-basis: fit-content;\n        border: 1px solid black;\n    }\n\n    td {\n        padding-right: 5px;\n    }\n    .question {\n        font-size: 1.5em;\n    }\n\n    .model {\n        font-weight: bold;\n        color: #ee3333;\n    }\n\n    .answer {\n        margin-bottom: 20px;\n    }\n\n    .details {\n        font-size: 0.9em;\n    }\n\n    .citation {\n        text-decoration: none;\n        color: #3322aa;\n        cursor: pointer;\n    }\n\n    .reference {\n        margin-bottom: 8px;\n    }\n</style>\n","<script>\n    import Answer from \"./Answer.svelte\";\n    export let group = [];\n  \n    $: modelDatePairs = group.map((m) => `${m.model} (${m.date})`);\n    $: startPair = modelDatePairs[0];\n    $: selectedModel = startPair.split(\" (\")[0];\n    $: selectedDate = startPair.split(\" \")[1].slice(1, -1);\n    function handler(event) {\n      const selectedPair = event.target.value;\n      selectedModel = selectedPair.split(\" (\")[0];\n      selectedDate = selectedPair.split(\" \")[1].slice(1, -1);\n    }\n  </script>\n  \n  <main>\n  <div class=\"answer-group\">\n    <label>Model & Date: </label>\n    <select value={startPair} on:change={handler}>\n      {#each modelDatePairs as pair}\n        <option value={pair}>{pair}</option>\n      {/each}\n    </select>\n    {#each group.filter((entry) => entry.model === selectedModel && entry.date === selectedDate) as entry}\n      <Answer\n        question={entry.question}\n        model={entry.model}\n        date={entry.date}\n        answer={entry.answer}\n        sources={entry.sources}\n      />\n    {/each}\n  </div>\n\n</main>","export default [\r\n  {\r\n    \"question\": \"What do bispecific CD38 antibodies bind to and how do they treat myeloma?\",\r\n    \"model\": \"paperqa-1.0.0\",\r\n    \"date\": \"2023-04-09\",\r\n    \"answer\": \"Bispecific CD38 antibodies bind to CD38, a protein expressed on the surface of multiple myeloma (MM) cells (Green2018, Cho2022 pages 14-15). These antibodies have two binding sites, one for CD38 and the other for CD3 on T cells, leading to T cell activation and subsequent killing of the myeloma cells (Cho2022 pages 14-15). In addition to blocking CD38, bispecific CD38 antibodies such as daratumumab and isatuximab also block immunosuppressive regulatory cells, including Treg, Breg, and myeloid-derived suppressor cells, leading to improved host-anti-tumor immunity (Cho2022 pages 1-2). Bispecific CD38 antibodies treat myeloma through pretargeted radioimmunotherapy (PRIT), which has demonstrated remarkable efficacy targeting tumor antigens (Green2018 pages 1-1). In murine xenograft models of MM and non-Hodgkin lymphoma (NHL), the CD38-bispecific construct demonstrated excellent blood clearance and tumor targeting, resulting in 100% complete remissions by day 12 in MM and NHL xenograft models, ultimately curing 80% of mice at optimal doses (Green2018 pages 1-1). However, the text does not provide information on the specific mechanisms of action of bispecific CD38 antibodies in newly diagnosed or relapsed/refractory patients (Verkleij2020 pages 1-1).\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"Verkleij2020 pages 1-1\",\r\n        \"text\": \"Verkleij, Christie P.M., et al. \\\"T-cell redirecting bispecific antibodies targeting BCMA for the treatment of multiple myeloma.\\\" Oncotarget, vol. 11, no. 45, 2020, pp. 4076-4081.\"\r\n      },\r\n      {\r\n        \"key\": \"Cho2022 pages 14-15\",\r\n        \"text\": \"Cho, Shih-Feng, et al. \\\"Bispecific antibodies in multiple myeloma treatment: A journey in progress.\\\" Frontiers in Oncology, vol. 12, 2022, pp. 1-14. DOI: 10.3389/fonc.2022.855946.\"\r\n      },\r\n      {\r\n        \"key\": \"Donk2018 pages 1-1\",\r\n        \"text\": \"vandeDonk, N.W.C.J., and Saad Z. Usmani. \\\"CD38 Antibodies in Multiple Myeloma: Mechanisms of Action and Modes of Resistance.\\\" Frontiers in Immunology, vol. 9, 2018, article 2134, doi:10.3389/\\ufb01mmu.2018.02134.\"\r\n      },\r\n      {\r\n        \"key\": \"Green2018 pages 1-1\",\r\n        \"text\": \"Green, Damian J., et al. \\\"CD38-bispecific antibody pretargeted radioimmunotherapy for multiple myeloma and other B-cell malignancies.\\\" Blood, vol. 131, no. 6, 2018, pp. 611-620.\"\r\n      },\r\n      {\r\n        \"key\": \"Cho2022 pages 1-2\",\r\n        \"text\": \"Cho, Shih-Feng, et al. \\\"Bispecific antibodies in multiple myeloma treatment: A journey in progress.\\\" Frontiers in Oncology, vol. 12, 2022, pp. 1-14. DOI: 10.3389/fonc.2022.855946.\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"How can carbon nanotubes be manufactured at scale?\",\r\n    \"model\": \"paperqa-1.0.0\",\r\n    \"date\": \"2023-04-09\",\r\n    \"answer\": \"Carbon nanotubes can be manufactured at scale using various methods, including electric arc discharge, chemical vapor deposition, and laser ablation pyrolysis (Saravanan2010). The electric-arc technique can generate large quantities of single-walled carbon nanotubes (SWNTs) with similar characteristics to those obtained by laser ablation (Journet1997). In the electric arc-discharge apparatus, the arc is generated between two electrodes in a reactor under a helium atmosphere, and a mixture of a metallic catalyst and graphite powder is used (Journet1997). The growth mechanism for SWNTs must be independent of the details of the technique used to make them (Journet1997). The CoMoCAT method, a catalytic method, has been used to synthesize single-wall carbon nanotubes (SWCNTs) at a small-scale production rate of approximately 100 grams per day (Gavankar2015). The decrease in energy requirement for carbon nanotube synthesis is observed with increased level of manufacturing readiness for high-pressure carbon monoxide conversion, chemical vapor deposition, and arc discharge manufacturing (Gavankar2015). Other methods for large-scale production of carbon nanotubes include CO2-assisted growth, fluidized bed catalytic chemical vapor deposition, and the use of natural materials as catalysts (The2012). However, challenges in growing large quantities of pure, defect-free nanotubes have limited their widespread use (De6119). While there are several methods for mass production of ceramic matrix composites (CMCs) reinforced with carbon nanotubes (CNTs), including casting methods such as slip casting, tape casting, and gel casting, the text does not directly answer the question of what the methods are for mass production of CNTs (Meshalkin2020).\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"Journet1997 pages 1-1\",\r\n        \"text\": \"Journet, C., Maser, W. K., Bernier, P., Loiseau, A., Lamy de la Chapelle, M., Lefrant, S., Deniard, P., Lee, R., & Fischer, J. E. (1997). Large-scale production of single-walled carbon nanotubes by the electric-arc technique. Nature, 388(6644), 756-758. doi: 10.1038/41972\"\r\n      },\r\n      {\r\n        \"key\": \"De6119 pages 5-6\",\r\n        \"text\": \"De Volder, Michael F. L., et al. \\\"Carbon Nanotubes: Present and Future Commercial Applications.\\\" Science, vol. 339, no. 6119, 2013, pp. 535-539.\"\r\n      },\r\n      {\r\n        \"key\": \"Gavankar2015 pages 4-5\",\r\n        \"text\": \"Gavankar, Sheetal, Sangwon Suh, and Arturo A. Keller. \\\"The Role of Scale and Technology Maturity in Life Cycle Assessment of Emerging Technologies: A Case Study on Carbon Nanotubes.\\\" Journal of Industrial Ecology, vol. 19, no. 1, 2015, pp. 102-114. DOI: 10.1111/jiec.12175.\"\r\n      },\r\n      {\r\n        \"key\": \"The2012 pages 10-10\",\r\n        \"text\": \"The citation for the article mentioned in the text would be: \\n\\nHuang, JiaQi, et al. \\\"A review of the large-scale production of carbon nanotubes: The practice of nanoscale process engineering.\\\" Chinese Science Bulletin, vol. 57, no. 2-3, 2012, pp. 157-166, doi: 10.1007/s11434-011-4879-z.\"\r\n      },\r\n      {\r\n        \"key\": \"Saravanan2010 pages 1-1\",\r\n        \"text\": \"Saravanan, M.S. Senthil, et al. \\\"Techno-economics of carbon nanotubes produced by open air arc discharge method.\\\" International Journal of Engineering, Science and Technology, vol. 2, no. 5, 2010, pp. 100-108.\"\r\n      },\r\n      {\r\n        \"key\": \"Joselevich2008 pages 2-2\",\r\n        \"text\": \"Joselevich, Ernesto, et al. \\\"Carbon Nanotube Synthesis and Organization.\\\" Carbon Nanotubes, edited by A. Jorio et al., vol. 111, Springer-Verlag Berlin Heidelberg, 2008, pp. 101-164.\"\r\n      },\r\n      {\r\n        \"key\": \"Meshalkin2020 pages 21-22\",\r\n        \"text\": \"Meshalkin, Valerii P., and Alexey V. Belyakov. \\\"Methods Used for the Compaction and Molding of Ceramic Matrix Composites Reinforced with Carbon Nanotubes.\\\" Materials 13.17 (2020): 3831.\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"How can carbon nanotubes be manufactured at scale?\",\r\n    \"model\": \"perplexity.ai\",\r\n    \"date\": \"2023-04-07\",\r\n    \"answer\": \"Carbon nanotubes can be manufactured at scale using various methods. One method is chemical vapor deposition (CVD), which utilizes high energy to atomize gaseous carbon sources such as methane, carbon monoxide, and acetylene[1]. Another method is laser ablation, which uses a high-power laser to vaporize a graphite source loaded with a metal catalyst[2]. Researchers at Western Michigan University\\n have also developed a method for forming carbon nanotubes in a \\nhigh-density, closely packed configuration, enabling their large-scale \\nproduction[3]. Recently, MIT\\n researchers have demonstrated that carbon nanotube transistors can be \\nmade swiftly in commercial facilities, with the same equipment used to \\nmanufacture silicon-based transistors[4].\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"1\",\r\n        \"text\": \"https://www.britannica.com/science/carbon-nanotube\"\r\n      },\r\n      {\r\n        \"key\": \"2\",\r\n        \"text\": \"https://www.azonano.com/article.aspx?ArticleID=1108\"\r\n      },\r\n      {\r\n        \"key\": \"3\",\r\n        \"text\": \"https://wmich.edu/research/large-scale\"\r\n      },\r\n      {\r\n        \"key\": \"4\",\r\n        \"text\": \"https://news.mit.edu/2020/carbon-nanotube-transistors-factory-0601\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"What do bispecific CD38 antibodies bind to and how do they treat myeloma?\",\r\n    \"model\": \"perplexity.ai\",\r\n    \"date\": \"2023-04-07\",\r\n    \"answer\": \"Bispecific CD38\\n antibodies are designed to bind to both CD38, a protein found on the \\nsurface of multiple myeloma (MM) cells, and CD3, a protein found on T \\ncells[1][2]. By binding to both CD38 and CD3, bispecific CD38 antibodies activate T cells to attack and kill MM cells[1][3]. This mechanism of action is similar to that of other anti-CD38 monoclonal antibodies, such as daratumumab and isatuximab[4].\\n Bispecific CD38 antibodies are a novel immunotherapeutic modality that \\nhas shown impressive preliminary efficacy in heavily treated MM patients[1]. They are expected to become an integral part of the MM treatment paradigm in the near future[1].\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"1\",\r\n        \"text\": \"https://aacrjournals.org/bloodcancerdiscov/article/2/5/423/665839/Bispecific-Antibodies-in-Multiple-Myeloma-Present\"\r\n      },\r\n      {\r\n        \"key\": \"2\",\r\n        \"text\": \"https://www.news-medical.net/whitepaper/20210817/Targeting-CD38CD3-in-the-immunotherapy-of-multiple-myeloma.aspx\"\r\n      },\r\n      {\r\n        \"key\": \"3\",\r\n        \"text\": \"https://www.tandfonline.com/doi/full/10.1080/13543784.2020.1814253\"\r\n      },\r\n      {\r\n        \"key\": \"4\",\r\n        \"text\": \"https://ashpublications.org/blood/article/138/Supplement%201/1580/480536/The-Role-of-CD38-in-Multiple-Myeloma-Cell-Biology\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"What therapeutics are available or being researched for ALS as of 2022?\",\r\n    \"model\": \"https://scite.ai/assistant\",\r\n    \"date\": \"2023-04-09\",\r\n    \"answer\": \"As of 2022, there are limited treatment options available for amyotrophic lateral sclerosis (ALS) patients [1]. The only two modestly efficacious disease-modifying drugs available are riluzole and edaravone [1][6]. However, there are several therapeutics being researched for ALS treatment. Cell-based therapy has been proposed as an ultimate source for regeneration of motor neurons (MNs) [2][4]. Recent completion of non-autologous fetal spinal stem cell transplant to ALS patients brought renewed hope for further human trials to cure the disease [2]. Autologous somatic stem cell-based human trials are now in track to reveal the outcome of the ongoing trials [2]. Furthermore, induced pluripotent stem cell (iPSC)-based ALS disease drug screen and autologous cell transplant options will broaden therapeutic options [2]. Astrocyte-based cell therapy is another potential treatment for ALS [3]. Embryonic stem cell-derived astrocytes behave as highly trophic \\u201cyoung astrocytes\\u201d, being able to delay disease onset and prolong survival when injected intrathecally in murine models of ALS overexpressing the SOD1G93A mutation [3]. The safety and therapeutic potential of these cells are currently being evaluated in a clinical trial in ALS patients [3]. Human umbilical cord blood (hUCB) cells may be a promising new treatment for ALS, mainly by providing a protective microenvironment for motor neuron survival [5]. Among multiple advantages, hUCB cells' production of various anti-inflammatory/growth/trophic factors makes them an attractive cell source for ALS therapy [5]. Biodistribution and optimal hUCB cell dose for transplantation have been determined in current ALS clinical trials [5]. In addition to cell-based therapy, positron emission tomography (PET) imaging has promise as a biomarker for ALS because it permits visualization of central nervous system (CNS) pathology in individuals living with ALS [1]. PET radioligands that target a variety of potential pathophysiological mechanisms\\u2014including cerebral metabolism, neuroinflammation, neuronal dysfunction, and oxidative stress\\u2014has enabled dynamic interrogation of molecular changes in ALS, in both natural history studies and human clinical trials [1]. In conclusion, while there are limited treatment options available for ALS patients, there are several promising therapeutics being researched, including cell-based therapy, astrocyte-based cell therapy, and human umbilical cord blood cells. PET imaging also has potential as a diagnostic biomarker for ALS.\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"1\",\r\n        \"text\": \"https://www.frontiersin.org/articles/10.3389/fneur.2019.00135/full\"\r\n      },\r\n      {\r\n        \"key\": \"2\",\r\n        \"text\": \"https://www.en-journal.org/journal/view.html?doi=10.5607/en.2014.23.3.207\"\r\n      },\r\n      {\r\n        \"key\": \"3\",\r\n        \"text\": \"https://stemcellres.biomedcentral.com/articles/10.1186/s13287-018-1006-y\"\r\n      },\r\n      {\r\n        \"key\": \"4\",\r\n        \"text\": \"10.4172/2325-9620.1000118\"\r\n      },\r\n      {\r\n        \"key\": \"5\",\r\n        \"text\": \"https://www.tandfonline.com/doi/full/10.1080/14712598.2017.1323862\"\r\n      },\r\n      {\r\n        \"key\": \"6\",\r\n        \"text\": \"https://onlinelibrary.wiley.com/doi/10.1002/med.21528\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"What therapeutics are available or being researched for ALS as of 2022?\",\r\n    \"model\": \"perplexity.ai\",\r\n    \"date\": \"2023-04-09\",\r\n    \"answer\": \"As of 2022, there are six FDA-approved drugs for treating ALS and its symptoms, including RELYVRIO, Radicava, Rilutek, Tiglutik, Exservan, and Nuedexta[1]. There are also several therapies being researched for ALS treatment. For example, an experimental drug is being tested in a global phase 3 clinical trial based on promising results from a study at Columbia University[2]. Tofersen is another therapy being investigated for treating ALS caused by mutations in the SOD1 gene[3]. Additionally, NU-9 is a potential ALS treatment that has shown to be more effective than existing FDA-approved drugs when given in combination with riluzole and edaravone[4]. The ALS Association is currently funding 121 active research projects in 12 countries with $44 million committed to research[5].\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"1\",\r\n        \"text\": \"https://www.als.org/navigating-als/living-with-als/fda-approved-drugs\"\r\n      },\r\n      {\r\n        \"key\": \"2\",\r\n        \"text\": \"https://www.cuimc.columbia.edu/news/promising-als-therapy-moves-closer-clinic\"\r\n      },\r\n      {\r\n        \"key\": \"3\",\r\n        \"text\": \"https://www.ajmc.com/view/overview-of-current-and-emerging-therapies-for-amyotrophic-lateral-sclerosis\"\r\n      },\r\n      {\r\n        \"key\": \"4\",\r\n        \"text\": \"https://news.northwestern.edu/stories/2022/05/new-als-drug-is-more-effective-than-existing-ones/\"\r\n      },\r\n      {\r\n        \"key\": \"5\",\r\n        \"text\": \"https://www.als.org/2022-year-review\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"How can I cluster protein structures output from a molecular dynamics trajectory?\",\r\n    \"model\": \"perplexity.ai\",\r\n    \"date\": \"2023-04-10\",\r\n    \"answer\": \"There are several ways to cluster protein structures output from a molecular dynamics trajectory. One common method is cluster analysis, which involves grouping similar conformations together[1]. Clustering algorithms have been widely used to reduce the dimensionality of molecular dynamics trajectories[2]. Principal Component Analysis (PCA) is another method that can be used to cluster protein structures[3]. The goal of clustering is to partition data so that data points inside a cluster are more similar to each other than they are to points outside a cluster[1]. Structural features from the substrate-binding cavity of the receptor can also be used to optimize docking experiments on a cloud[2].\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"1\",\r\n        \"text\": \"https://amberhub.chpc.utah.edu/clustering-a-protein-trajectory/\"\r\n      },\r\n      {\r\n        \"key\": \"2\",\r\n        \"text\": \"https://pubmed.ncbi.nlm.nih.gov/25873944/\"\r\n      },\r\n      {\r\n        \"key\": \"3\",\r\n        \"text\": \"https://www.nature.com/articles/s41598-022-13714-z\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"How can I cluster protein structures output from a molecular dynamics trajectory?\",\r\n    \"model\": \"https://scite.ai/assistant\",\r\n    \"date\": \"2023-04-10\",\r\n    \"answer\": \"To cluster protein structures output from a molecular dynamics trajectory, several methods can be used. One such method is fuzzy clustering, which can locate classes of similar three-dimensional conformations explored during a molecular dynamics simulation [1]. Another method is quantum clustering, which can objectively cluster the conformations sampled by molecular dynamics simulations performed on different ligand-bound structures of the protein [2]. K-means clustering is another widely used clustering algorithm that can be implemented in the protein essential dynamics subspace defined by principal component analysis on the molecular dynamics trajectory [4]. In addition to clustering, visualizing the solvent paths entering and leaving cavities of the protein can also be useful in studying the route and dynamics of the exchange of tightly bound internal water molecules with the bulk solvent [3]. Overall, the choice of clustering method depends on the specific research question and the type of data being analyzed. It is important to choose a method that is appropriate for the data and can provide meaningful insights into the protein structures.\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"1\",\r\n        \"text\": \"https://onlinelibrary.wiley.com/doi/10.1002/prot.340140211\"\r\n      },\r\n      {\r\n        \"key\": \"2\",\r\n        \"text\": \"https://pubs.rsc.org/en/content/articlelanding/2011/MB/c1mb05038a\"\r\n      },\r\n      {\r\n        \"key\": \"3\",\r\n        \"text\": \"https://onlinelibrary.wiley.com/doi/10.1111/j.1467-8659.2008.01227.x\"\r\n      },\r\n      {\r\n        \"key\": \"4\",\r\n        \"text\": \"https://www.worldscientific.com/doi/abs/10.1142/S0219633613410083\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"What factors should I consider for selecting a catalyst for a Diels-Alder reaction?\",\r\n    \"model\": \"perplexity.ai\",\r\n    \"date\": \"2023-04-10\",\r\n    \"answer\": \"When selecting a catalyst for a Diels-Alder reaction, there are several factors to consider. The diene component must be able to assume an s-cis conformation, and electron-withdrawing groups on the dienophile facilitate the reaction. Electron-donating groups on the diene also facilitate the reaction[1]. Controlling the reaction to select for the endo product relies on changing the HOMO and/or LUMO of the system[2]. The reactivity and stereoselectivity in the Lewis acid-catalyzed Diels-Alder reaction are controlled by a combination of several interaction terms[3]. Physical factors leading to the computed periodic reactivity trend upon going from the uncatalyzed to the bond-catalyzed Diels-Alder reactions can be analyzed and compared[4]. Additionally, external electric fields can be used as a catalyst to manipulate the reactivity and selectivity of the reaction[5].\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"1\",\r\n        \"text\": \"https://chem.libretexts.org/Courses/University_of_Illinois_Springfield/UIS%3A_CHE_269_(Morsch_and_Andrews)/Chapters/Chapter_16%3A_Conjugation%2C_Resonance%2C_and_Dienes/16.11_Rules_of_the_Diels%E2%80%93Alder_Reaction\"\r\n      },\r\n      {\r\n        \"key\": \"2\",\r\n        \"text\": \"https://chem.libretexts.org/Courses/University_of_California_Davis/UCD_Chem_231A%3A_Methods_of_Organic_Synthesis/Text/Diels-Alder_Reaction\"\r\n      },\r\n      {\r\n        \"key\": \"3\",\r\n        \"text\": \"https://chemistry-europe.onlinelibrary.wiley.com/doi/full/10.1002/open.202000112\"\r\n      },\r\n      {\r\n        \"key\": \"4\",\r\n        \"text\": \"https://chemistry-europe.onlinelibrary.wiley.com/doi/full/10.1002/chem.202100522\"\r\n      },\r\n      {\r\n        \"key\": \"5\",\r\n        \"text\": \"https://www.nature.com/articles/nature16989/\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"What factors should I consider for selecting a catalyst for a Diels-Alder reaction?\",\r\n    \"model\": \"https://scite.ai/assistant\",\r\n    \"date\": \"2023-04-10\",\r\n    \"answer\": \"When selecting a catalyst for a Diels-Alder reaction, several factors should be considered. The nature of the catalyst can affect the reaction rate, selectivity, and yield of the product. The following are some factors to consider when selecting a catalyst for a Diels-Alder reaction: 1. Lewis acidity: Catalysts with high Lewis acidity can activate the dienophile and diene, leading to faster reaction rates and higher yields. For example, silica and alumina modified by Lewis acids have been shown to be efficient catalysts in Diels-Alder reactions of carbonyl-containing dienophiles [2]. 2. Chirality: Chiral catalysts can induce enantioselectivity in the reaction, leading to the formation of a single enantiomer of the product. For example, oxazaborolidinone-catalyzed enantioselective Diels-Alder reactions have been reported [1]. 3. Stability: Catalysts that are stable under the reaction conditions can be reused, reducing the cost of the reaction. For example, the catalyst SiO2\\u00b7AlClEt2 retains a great deal of its catalytic activity when recovered or stored in the open air for one month [2]. 4. Endo/exo selectivity: Catalysts can influence the endo/exo selectivity of the reaction, leading to the formation of either endo or exo adducts. For example, allo-threonine-derived O-acyl-B-phenyl-oxazaborolidinones are highly enantioselective Lewis acid catalysts for the Diels-Alder reaction of simple acyclic enone dienophiles, expanding the scope of ketone dienophiles and dienes [1]. 5. Reactivity: Catalysts can affect the reactivity of the dienophile and diene, leading to the formation of the desired product. For example, carbocations such as Ph3C+ have been shown to be extremely efficient, mild, and selective Lewis acid catalysts for Diels-Alder reactions [3]. In summary, when selecting a catalyst for a Diels-Alder reaction, factors such as Lewis acidity, chirality, stability, endo/exo selectivity, and reactivity should be considered. The choice of catalyst can significantly affect the reaction rate, selectivity, and yield of the product [1]. [2][3]\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"1\",\r\n        \"text\": \"https://pubs.acs.org/doi/10.1021/jo702043g\"\r\n      },\r\n      {\r\n        \"key\": \"2\",\r\n        \"text\": \"https://onlinelibrary.wiley.com/doi/10.1002/chin.199337096\"\r\n      },\r\n      {\r\n        \"key\": \"3\",\r\n        \"text\": \"https://onlinelibrary.wiley.com/doi/10.1002/chin.201427035\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"Are SELFIEs or SMILES a better representation of molecules for deep learning?\",\r\n    \"model\": \"perplexity.ai\",\r\n    \"date\": \"2023-04-10\",\r\n    \"answer\": \"Based on the provided search results, selfies and smiles are both used as molecular representations for deep learning. SMILES is a popular string-based representation that has been used in computational chemistry for decades[1][2]. SELFIES is a newer representation that has been shown to be more diverse and robust than SMILES[3][1][4]. Geometric representations are also becoming more important in molecular deep learning[5]. Therefore, the choice between selfies or smiles as a better representation of molecules for deep learning may depend on the specific application and the type of information that needs to be extracted from the molecular structure.\\n\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"1\",\r\n        \"text\": \"https://arxiv.org/abs/2204.00056\"\r\n      },\r\n      {\r\n        \"key\": \"2\",\r\n        \"text\": \"https://iopscience.iop.org/article/10.1088/2632-2153/aba947\"\r\n      },\r\n      {\r\n        \"key\": \"3\",\r\n        \"text\": \"https://arxiv.org/abs/1905.13741\"\r\n      },\r\n      {\r\n        \"key\": \"4\",\r\n        \"text\": \"https://deepai.org/publication/selfies-and-the-future-of-molecular-string-representations\"\r\n      },\r\n      {\r\n        \"key\": \"5\",\r\n        \"text\": \"https://www.nature.com/articles/s42256-021-00418-8\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"Are SELFIEs or SMILES a better representation of molecules for deep learning?\",\r\n    \"model\": \"https://scite.ai/assistant\",\r\n    \"date\": \"2023-04-10\",\r\n    \"answer\": \"Deep learning has brought a dramatic development in molecular property prediction that is crucial in the field of drug discovery using various representations such as fingerprints, SMILES, and graphs [1]. SMILES is commonly used in chemistry applications with SMILES sequences [2]. However, SMILES has a limitation in that it is hard to reflect chemical properties [1]. SELFIEs, on the other hand, have been shown to be superior to SMILES for tasks such as Optical Chemical Entity Recognition [4][5]. SELFIEs match the representation used in MACCS, which is commonly used in regression models [2]. However, using SELFIEs over SMILES does not necessarily translate to better supervised learning performance [2]. In addition, there exists a performance gap between the existing unpretrained SMILES-based models and graph-based models at large-scale benchmark results, while pretrain models are resource-demanding at training [3]. Therefore, it can be concluded that SELFIEs are a better representation of molecules for deep learning than SMILES, but the choice of representation depends on the specific task and the availability of resources.\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"1\",\r\n        \"text\": \"https://www.nature.com/articles/s41598-021-90259-7\"\r\n      },\r\n      {\r\n        \"key\": \"2\",\r\n        \"text\": \"https://chemrxiv.org/engage/chemrxiv/article-details/613268f0d5f0803706ba0c79\"\r\n      },\r\n      {\r\n        \"key\": \"3\",\r\n        \"text\": \"https://arxiv.org/abs/2112.13305\"\r\n      },\r\n      {\r\n        \"key\": \"4\",\r\n        \"text\": \"https://chemrxiv.org/engage/chemrxiv/article-details/60c756c2567dfe48eaec654c\"\r\n      },\r\n      {\r\n        \"key\": \"5\",\r\n        \"text\": \"https://chemrxiv.org/engage/chemrxiv/article-details/60c75681567dfe722dec64d6\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"What are promising targets for Alzheimer's disease (other than ABeta)\",\r\n    \"model\": \"perplexity.ai\",\r\n    \"date\": \"2023-04-10\",\r\n    \"answer\": \"There are several promising targets for Alzheimer's disease beyond Abeta. These include:\\n\\u2022 Lecanemab, a medicine that slows cognitive decline in people with early Alzheimer's disease by 27% [1]\\n\\u2022 Immune cells, toxic protein tangles, and brain waves[2]\\n\\u2022 Tau proteins, which are a promising target for passive immunotherapy[3]\\n\\u2022 APOE4, pericytes, and Cyclophilin A, which have been shown to accelerate blood-brain barrier breakdown and are potential targets for treatment[4]\\n\\u2022 Immunotherapies based on other targets such as tau, microglia, and the gut-brain axis are also under development[5].\\n\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"1\",\r\n        \"text\": \"https://www.mayoclinic.org/diseases-conditions/alzheimers-disease/in-depth/alzheimers-treatments/art-20047780\"\r\n      },\r\n      {\r\n        \"key\": \"2\",\r\n        \"text\": \"https://www.npr.org/sections/health-shots/2021/08/09/1026207499/new-treatments-look-for-ways-to-protect-the-brain-from-alzheimers\"\r\n      },\r\n      {\r\n        \"key\": \"3\",\r\n        \"text\": \"https://pubmed.ncbi.nlm.nih.gov/32682954/\"\r\n      },\r\n      {\r\n        \"key\": \"4\",\r\n        \"text\": \"https://www.sciencedaily.com/releases/2021/06/210614131220.htm\"\r\n      },\r\n      {\r\n        \"key\": \"5\",\r\n        \"text\": \"https://translationalneurodegeneration.biomedcentral.com/articles/10.1186/s40035-022-00292-3\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"What are promising targets for Alzheimer's disease (other than ABeta)\",\r\n    \"model\": \"https://scite.ai/assistant\",\r\n    \"date\": \"2023-04-10\",\r\n    \"answer\": \"Alzheimer's disease is a multifactorial neurodegenerative disorder with many drug targets contributing to its etiology [3]. While increased production and deposition of amyloid beta-protein (Abeta) are believed to be key pathogenic events in Alzheimer's disease, other potential therapeutic targets have been identified [1][2][4]. Glycogen synthase kinase-3 beta (GSK-3\\u03b2) and cyclin-dependent kinase 5 (CDK5) have been identified as being involved in the pathological hyperphosphorylation of tau proteins, which leads to the formation of neurofibrillary tangles and causes Alzheimer's disease [3]. Inhibition of p38 mitogen-activated protein kinase (MAPK) is also considered a promising strategy for the treatment of Alzheimer's disease [4]. Additionally, peripheral blood biomarkers offer a promising, non-intrusive mechanism for early Alzheimer's disease diagnosis [5]. The corpus callosum has also been identified as a novel target for human neural stem cell transplantation in transgenic Alzheimer's disease mouse models [6]. Therefore, potential therapeutic targets for Alzheimer's disease, other than Abeta, include GSK-3\\u03b2, CDK5, p38 MAPK, peripheral blood biomarkers, and the corpus callosum.\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"1\",\r\n        \"text\": \"https://academic.oup.com/hmg/article/18/23/4492/664197\"\r\n      },\r\n      {\r\n        \"key\": \"2\",\r\n        \"text\": \"https://pubs.acs.org/doi/10.1021/acs.joc.1c01970\"\r\n      },\r\n      {\r\n        \"key\": \"3\",\r\n        \"text\": \"https://www.oncotarget.com/article/15085/text/\"\r\n      },\r\n      {\r\n        \"key\": \"4\",\r\n        \"text\": \"https://www.mdpi.com/1420-3049/22/8/1287\"\r\n      },\r\n      {\r\n        \"key\": \"5\",\r\n        \"text\": \"https://www.mdpi.com/2073-4425/12/11/1794\"\r\n      },\r\n      {\r\n        \"key\": \"6\",\r\n        \"text\": \"https://onlinelibrary.wiley.com/doi/10.1002/acn3.443\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"How do Salamanders breathe?\",\r\n    \"model\": \"perplexity.ai\",\r\n    \"date\": \"2023-04-10\",\r\n    \"answer\": \"Salamanders can breathe through their gills, lungs, skin, mouth, and throat. The process of breathing can differ from type to type of salamanders. Some salamanders breathe through their gills, while others breathe through their lungs. Salamanders primarily rely on their skin for respiration, which is thin and permeable, allowing oxygen to diffuse into their bloodstream and carbon dioxide to diffuse out. Salamanders that live on land lose their gills as they grow older. Salamander larvae breathe through their gills, while adult salamanders such as the lungless salamanders breathe through their skin and the lining of their mouth, which is called buccopharyngeal respiration. [1][2][3][4][5]\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"1\",\r\n        \"text\": \"https://k12.libretexts.org/Bookshelves/Science_and_Technology/Life_Science_for_Middle_School_(CK-12)/10%3A_Vertebrates/10.8%3A_Salamanders\"\r\n      },\r\n      {\r\n        \"key\": \"2\",\r\n        \"text\": \"https://acuariopets.com/how-do-salamanders-breathe/\"\r\n      },\r\n      {\r\n        \"key\": \"3\",\r\n        \"text\": \"https://amphibianplanet.com/how-salamanders-breathe/\"\r\n      },\r\n      {\r\n        \"key\": \"4\",\r\n        \"text\": \"https://www.britannica.com/science/respiratory-system/Amphibians\"\r\n      },\r\n      {\r\n        \"key\": \"5\",\r\n        \"text\": \"https://www.burkemuseum.org/collections-and-research/biology/herpetology/all-about-amphibians/all-about-amphibians\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"How do Salamanders breathe?\",\r\n    \"model\": \"https://scite.ai/assistant\",\r\n    \"date\": \"2023-04-10\",\r\n    \"answer\": \"Salamanders possess a pair of lungs for active air breathing, but the lung respiration is fully operational only during the late stage of development, particularly after metamorphosis. Larval salamanders mainly exchange air through the gills and skin, thus sparing the developing lungs [1]. Therefore, salamanders breathe through their skin and gills during their larval stage. However, after metamorphosis, they switch to breathing through their lungs [1].\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"1\",\r\n        \"text\": \"https://onlinelibrary.wiley.com/doi/10.1111/cpr.13369\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"What methods can be used to explain predictions from black box models in chemistry?\",\r\n    \"model\": \"perplexity.ai\",\r\n    \"date\": \"2023-04-10\",\r\n    \"answer\": \"Several methods can be used to explain predictions from black box models in chemistry. One approach is to use explainable AI (XAI) to interpret the entire model at once or to explain an individual prediction[1][2][3]. Another method is to estimate the causal effect of each input variable or feature on the output variable[4]. Some popular ways to explain black box models include using partial dependence plots, permutation feature importance, and SHAP values[5].\\n\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"1\",\r\n        \"text\": \"https://engineering.dynatrace.com/blog/understanding-black-box-ml-models-with-explainable-ai/\"\r\n      },\r\n      {\r\n        \"key\": \"2\",\r\n        \"text\": \"https://www.zdnet.com/article/explainable-ai-artificial-intelligence-a-guide-for-making-black-box-machine-learning-models-explainable/\"\r\n      },\r\n      {\r\n        \"key\": \"3\",\r\n        \"text\": \"https://link.springer.com/chapter/10.1007/978-3-030-79108-7_8\"\r\n      },\r\n      {\r\n        \"key\": \"4\",\r\n        \"text\": \"https://ist.psu.edu/research/projects/black-box-predictive-models\"\r\n      },\r\n      {\r\n        \"key\": \"5\",\r\n        \"text\": \"https://www.elderresearch.com/blog/how-and-why-to-interpret-black-box-models/\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"What methods can be used to explain predictions from black box models in chemistry?\",\r\n    \"model\": \"https://scite.ai/assistant\",\r\n    \"date\": \"2023-04-10\",\r\n    \"answer\": \"Black box models in chemistry, such as deep learning models, lack interpretability, which can make chemists skeptical of their use in decision making [1][2]. Explainable artificial intelligence (XAI) is a branch of AI that addresses this drawback by providing tools to interpret black box models and their predictions [1][2]. XAI methods like chemical counterfactuals and descriptor explanations can explain deep learning predictions while giving insight into structure-property relationships [1][2]. XAI methods can also be used to predict molecular properties and optimize molecular properties and synthetic pathways [3][4]. In addition, machine learning models can be combined with quantum chemistry to speed up the calculation of molecular properties while maintaining accuracy [5].\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"1\",\r\n        \"text\": \"https://chemrxiv.org/engage/chemrxiv/article-details/639222a114d92d7cd6a65e90\"\r\n      },\r\n      {\r\n        \"key\": \"2\",\r\n        \"text\": \"https://pubs.acs.org/doi/10.1021/acs.jctc.2c01235\"\r\n      },\r\n      {\r\n        \"key\": \"3\",\r\n        \"text\": \"https://chemrxiv.org/engage/chemrxiv/article-details/63e699bafcfb27a31f8dd492\"\r\n      },\r\n      {\r\n        \"key\": \"4\",\r\n        \"text\": \"https://pubs.acs.org/doi/10.1021/acs.jmedchem.1c01789\"\r\n      },\r\n      {\r\n        \"key\": \"5\",\r\n        \"text\": \"https://pubs.acs.org/doi/abs/10.1021/cen-09714-scicon6\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"What materials and energy are required input to use microorganisms for synthesis of plastics?\",\r\n    \"model\": \"perplexity.ai\",\r\n    \"date\": \"2023-04-10\",\r\n    \"answer\": \"The input materials and energy required to use microorganisms for the synthesis of plastics depend on the specific process used. However, some general information can be found in the provided search results. For example, microbial electrosynthesis can reduce energy input compared to using water as an electron donor[1]. Photosynthesis is a process that uses light energy to construct glucose molecules from water and carbon dioxide, which can provide energy and fixed carbon for organisms[2][3]. Some bio-based monomers and polymers can be synthesized using microbes[4]. Synthetic biology has the potential to enable sustainable manufacturing of chemicals, including plastics, using microbes[5].\\n\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"1\",\r\n        \"text\": \"https://www.nature.com/articles/nrmicro2422/\"\r\n      },\r\n      {\r\n        \"key\": \"2\",\r\n        \"text\": \"https://www.britannica.com/science/photosynthesis\"\r\n      },\r\n      {\r\n        \"key\": \"3\",\r\n        \"text\": \"https://www.khanacademy.org/science/ap-biology/cellular-energetics/photosynthesis/a/intro-to-photosynthesis\"\r\n      },\r\n      {\r\n        \"key\": \"4\",\r\n        \"text\": \"https://www.sciencedirect.com/science/article/abs/pii/S096085242101498X\"\r\n      },\r\n      {\r\n        \"key\": \"5\",\r\n        \"text\": \"https://www.nature.com/articles/s41587-022-01248-8\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"What materials and energy are required input to use microorganisms for synthesis of plastics?\",\r\n    \"model\": \"https://scite.ai/assistant\",\r\n    \"date\": \"2023-04-10\",\r\n    \"answer\": \"Microbial synthesis of plastics from renewable resources has attracted considerable attention in recent years [1]. Polyesters such as polyethylene terephthalate (PET) are amenable to biological degradation due to the action of microbial polyester hydrolases [2]. The hydrolysis products obtained from PET can be used for the synthesis of novel PET as well as become a potential carbon source for microorganisms [2]. Microorganisms and biomass can also be used for the synthesis of the constituent monomers of PET from renewable sources [2]. The use of microalgal biomass as a feedstock for PHA synthesis presents a low-cost solution [3]. Activated sludge processes can be used for treating wastewater and producing PHAs [4]. The energy required for microbial synthesis of plastics can be generated from renewable resources [1]. Therefore, the materials required input to use microorganisms for synthesis of plastics include renewable carbohydrate sources, microorganisms, biomass, and energy from renewable resources.\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"1\",\r\n        \"text\": \"https://onlinelibrary.wiley.com/doi/10.1002/anie.200301655\"\r\n      },\r\n      {\r\n        \"key\": \"2\",\r\n        \"text\": \"https://www.mdpi.com/2073-4425/10/5/373\"\r\n      },\r\n      {\r\n        \"key\": \"3\",\r\n        \"text\": \"https://www.frontiersin.org/articles/10.3389/fbioe.2022.879476/full\"\r\n      },\r\n      {\r\n        \"key\": \"4\",\r\n        \"text\": \"https://www.mrforum.com/product/9781644901335-6/\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"Why do birds flock?\",\r\n    \"model\": \"perplexity.ai\",\r\n    \"date\": \"2023-04-10\",\r\n    \"answer\": \"Birds flock together for various reasons, including safety, warmth, and finding food[1][2][3][4]. Flocking can help birds avoid predators, share body heat, and locate food sources more efficiently. Flocking behavior can also be a way for birds to socialize and communicate with each other. The coordinated movements of birds in a flock are thought to be the result of each bird following simple rules based on the movements of its neighbors[5].\\n\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"1\",\r\n        \"text\": \"https://theconversation.com/why-do-flocks-of-birds-swoop-and-swirl-together-in-the-sky-a-biologist-explains-the-science-of-murmurations-176194\"\r\n      },\r\n      {\r\n        \"key\": \"2\",\r\n        \"text\": \"https://www.psychologytoday.com/us/blog/creating-connection/202012/why-do-birds-flock-together\"\r\n      },\r\n      {\r\n        \"key\": \"3\",\r\n        \"text\": \"https://news.yahoo.com/why-flocks-black-birds-suddenly-160130498.html?fr=sycsrp_catchall\"\r\n      },\r\n      {\r\n        \"key\": \"4\",\r\n        \"text\": \"https://www.columbia-audubon.org/birds-in-big-numbers-flocks-of-blackbirds-and-starlings/\"\r\n      },\r\n      {\r\n        \"key\": \"5\",\r\n        \"text\": \"https://earthsky.org/earth/how-do-flocking-birds-move-in-unison/\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"Why do birds flock?\",\r\n    \"model\": \"https://scite.ai/assistant\",\r\n    \"date\": \"2023-04-10\",\r\n    \"answer\": \"Birds flock for various reasons, including foraging efficiency, predation avoidance, and social behavior [1]. Mixed-species flocks of birds involve species with different roles and foraging strategies and are ubiquitous in forest environments [1]. The diversity of foraging strategies occurring in a mixed flock reflects the diversity of participant species [1]. One of the main benefits of participating in mixed-species flocks is increased foraging efficiency [1]. However, feeding benefits remain under debate, probably because not all participants receive this benefit in the same way [1]. Species roles can broadly be categorized into leaders that attract others to form the flock, as well as lead the flock's movement; and follower species [1]. The predator avoidance hypothesis suggests that birds in mixed flocks increase their vigilance levels and decrease their predation risk [2]. The foraging efficiency hypothesis suggests that birds in mixed flocks increase their foraging efficiency and/or can spend more time feeding and less time looking out for predators [3]. The social behavior hypothesis suggests that birds flock for social reasons, such as to find mates or to learn from other birds [4]. In conclusion, birds flock for various reasons, including foraging efficiency, predation avoidance, and social behavior, and mixed-species flocks involve species with different roles and foraging strategies [1].\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"1\",\r\n        \"text\": \"https://onlinelibrary.wiley.com/doi/10.1111/ibi.13162\"\r\n      },\r\n      {\r\n        \"key\": \"2\",\r\n        \"text\": \"https://link.springer.com/article/10.1007/s10164-004-0124-4\"\r\n      },\r\n      {\r\n        \"key\": \"3\",\r\n        \"text\": \"https://onlinelibrary.wiley.com/doi/10.1111/btp.12551\"\r\n      },\r\n      {\r\n        \"key\": \"4\",\r\n        \"text\": \"https://www.tandfonline.com/doi/abs/10.1080/00306525.1989.9639611\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"How can carbon nanotubes be manufactured at scale?\",\r\n    \"model\": \"https://scite.ai/assistant\",\r\n    \"date\": \"2023-04-10\",\r\n    \"answer\": \"Carbon nanotubes can be manufactured at scale using various methods. One method is the thermal decomposition of a ferrocenyl compound in the presence of a multi(ethynyl)aromatic compound [1]. Another method is the use of an arc-jet plasma of high temperature to decompose methane [2]. Ethanol thermal reduction process can also be used to synthesize carbon nanotubes on a large scale [3]. The flame method is another simple method that can be used to synthesize carbon nanotubes [4]. Large-scale production of carbon nanotubes can also be achieved by using millimeter-diameter spheres as growth substrates [5]. The method described in [1] permits the large-scale production of carbon nanotubes in a shaped, solid configuration. The carbon nanotubes form under atmospheric pressure during the carbonization process above 500 \\u00b0C in the carbonaceous solid. The Fe atoms, nanoclusters, and/or nanoparticles formed from the decomposition of the ferrocenyl compound are the key to the formation of the carbon nanotubes in the developing carbonaceous solid by reacting with the developing polycondensed aromatic ring system. The arc-jet plasma process described in [2] is continuous and easily scalable, making it a promising technique for the large-scale commercial production of carbon nanotubes. The optimal operating condition for the production of high purity multi-walled carbon nanotubes was found in this study. The ethanol thermal reduction process described in [3] uses ethanol as the carbon source and magnesium as the reductant. This method avoids the use of toxic or corrosive reagents and can potentially be applied on the scale of industrial production. The flame method described in [4] is a new and simple method that may have the possibility of large-scale mass production for the synthesis of carbon nanotubes. It needs not the vacuum environment and carbon nanotubes can be captured at the normal atmospheric pressure. The use of millimeter-diameter spheres as growth substrates for the large scale and continuous production of aligned carbon nanotube arrays is reported in [5]. This technique is more productive than the conventional process on flat wafers because of the higher available growth surface and the good fluidity of the spherical substrates. In conclusion, there are various methods for the large-scale production of carbon nanotubes, including thermal decomposition, arc-jet plasma, ethanol thermal reduction, flame method, and the use of millimeter-diameter spheres as growth substrates. Each method has its advantages and disadvantages, and the choice of method depends on the specific application and requirements.\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"1\",\r\n        \"text\": \"https://pubs.acs.org/doi/10.1021/jp0665527\"\r\n      },\r\n      {\r\n        \"key\": \"2\",\r\n        \"text\": \"https://www.sciencedirect.com/science/article/abs/pii/S1567173905001926?via%3Dihub\"\r\n      },\r\n      {\r\n        \"key\": \"3\",\r\n        \"text\": \"https://pubs.acs.org/doi/10.1021/ja035763b\"\r\n      },\r\n      {\r\n        \"key\": \"4\",\r\n        \"text\": \"https://www.scientific.net/AMR.1048.383\"\r\n      },\r\n      {\r\n        \"key\": \"5\",\r\n        \"text\": \"https://onlinelibrary.wiley.com/doi/10.1002/cvde.200704249\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"What do bispecific CD38 antibodies bind to and how do they treat myeloma?\",\r\n    \"model\": \"https://scite.ai/assistant\",\r\n    \"date\": \"2023-04-10\",\r\n    \"answer\": \"CD38 is a transmembrane glycoprotein that is highly expressed in almost all myeloma cells, making it an attractive treatment target [1]. Bispecific antibodies targeting CD38 and CD3 have been developed as a therapeutic strategy for multiple myeloma [2]. These antibodies recruit effector T cells to CD38-expressing myeloma cells and induce antibody-dependent cell-mediated cytotoxicity (ADCC) [2]. Anti-CD38 monoclonal antibodies have been approved for first-line treatment in non-transplantable multiple myeloma patients [1]. Isatuximab-irfc and daratumumab are examples of anti-CD38 monoclonal antibodies that have been approved for the treatment of multiple myeloma [4]. However, it has been found that anti-CD38 monoclonal antibodies bind to CD38 on red blood cells (RBCs) and cause pan agglutination in indirect antiglobulin test (IAT), resulting in false positives of IAT and thereby interfering with blood bank testing and leading to the delay of further diagnosis and treatment [1]. Bispecific CD38 antibodies have the potential to overcome the limitations of current therapies in patients with multiple myeloma by triggering the complete elimination of malignant multiple myeloma cells in patients, including low-expressing cells that may evade daratumumab, with the potential to induce profound clinical responses [3]. In conclusion, bispecific CD38 antibodies bind to CD38 on myeloma cells and recruit effector T cells to induce ADCC, making them an effective therapeutic strategy for multiple myeloma.\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"1\",\r\n        \"text\": \"https://onlinelibrary.wiley.com/doi/10.1002/jcla.23832\"\r\n      },\r\n      {\r\n        \"key\": \"2\",\r\n        \"text\": \"https://ashpublications.org/blood/article/128/22/2097/100388/The-Trifunctional-Antibody-tri-31C2-Targeting-CD38\"\r\n      },\r\n      {\r\n        \"key\": \"3\",\r\n        \"text\": \"https://aacrjournals.org/clincancerres/article/25/13/3921/81953/Targeting-Multiple-Myeloma-with-AMG-424-a-Novel\"\r\n      },\r\n      {\r\n        \"key\": \"4\",\r\n        \"text\": \"https://jamanetwork.com/journals/jama/article-abstract/2764168?utm_campaign=scite&utm_source=scite&utm_medium=referral\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"What do bispecific CD38 antibodies bind to and how do they treat myeloma?\",\r\n    \"model\": \"paperqa-1.1.1\",\r\n    \"date\": \"2023-04-11\",\r\n    \"answer\": \"Bispecific CD38 antibodies are a promising immunotherapy for the treatment of multiple myeloma. These antibodies work by redirecting T cells to attack CD38-expressing myeloma cells (Shih2022). CD38 is a promising target for immunotherapy in multiple myeloma due to its high expression on myeloma cells and its role in regulating the immune system (Shih2022). Specific examples of CD38-targeting bispecific antibodies mentioned in the literature include BI38-3, MEDI2228, and AMG 424 (Shih2022). However, neither Shih2022 nor Verkleij4076 provide a direct quote that specifically answers the question of what bispecific CD38 antibodies bind to and how they treat myeloma. \\n\\nThat being said, other sources suggest that CD38-targeting antibodies, such as daratumumab or isatuximab, are used in combination therapy and can be effective in eliminating myeloma cells (Verkleij4076). These antibodies bind to CD38 on the surface of myeloma cells, leading to antibody-dependent cellular cytotoxicity (ADCC) and complement-dependent cytotoxicity (CDC) (Palumbo2016). ADCC involves the binding of the antibody to the target cell, which then activates immune cells to attack and kill the target cell. CDC involves the activation of the complement system, which leads to the formation of a membrane attack complex that can lyse the target cell (Palumbo2016). \\n\\nIn summary, while the literature suggests that bispecific CD38 antibodies are a promising immunotherapy for the treatment of multiple myeloma, the specific mechanism of action of these antibodies is not provided in the sources available. However, other CD38-targeting antibodies, such as daratumumab or isatuximab, are known to bind to CD38 on the surface of myeloma cells and induce ADCC and CDC, leading to the elimination of myeloma cells (Verkleij4076, Palumbo2016). \\n\\nSources: \\n- Shih2022 pages 14-15\\n- Verkleij4076 pages 1-1\\n- Palumbo2016\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"Shih2022 pages 14-15\",\r\n        \"text\": \"Shih-Feng Cho, Tsung-Jang Yeh, K. Anderson, and Y. Tai. Bispecific antibodies in multiple myeloma treatment: a journey in progress. Frontiers in Oncology, 2022.\"\r\n      },\r\n      {\r\n        \"key\": \"Verkleij4076 pages 1-1\",\r\n        \"text\": \"C. P. Verkleij, K. Frerichs, M. Broekmans, S. Absalah, P. W. Maas-Bosman, Sandy Kruyswijk, I. Nijhof, T. Mutis, S. Zweegman, and N. V. D. van de Donk. T-cell redirecting bispecific antibodies targeting bcma for the treatment of multiple myeloma. Oncotarget, 11:4076 - 4081, 2020.\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"What therapeutics are available or being researched for ALS as of 2022?\",\r\n    \"model\": \"paperqa-1.1.1\",\r\n    \"date\": \"2023-04-11\",\r\n    \"answer\": \"As of 2022, several antisense therapeutics are being researched for ALS, including BIIB105, an antisense therapeutic designed to decrease ATXN2 expression, which has demonstrated increased survival in a mouse model of TDP-43 ALS and is currently undergoing phase I clinical evaluation (Roberts2022 pages 11-12). Additionally, an investigational FUS-targeted AO (ION363) has been administered to one patient, and a phase I-III clinical trial for this drug has recently been announced (Roberts2022 pages 11-12). However, the C9orf72 targeting AO BIIB078 was recently evaluated in phase I clinical trial and designed to selectively target C9orf72 transcripts with repeat expansions, but the trial was terminated in March 2022 due to not meeting primary or secondary endpoints (Roberts2022 pages 11-12). Alternative AO strategies and sequences targeting C9orf72 are currently undergoing clinical evaluation, including WVE-004 and a\\ufb01nersen (Roberts2022 pages 11-12). Tofersen (BIIB067) is an antisense therapy designed to target and reduce SOD1 mRNA, currently under evaluation in phase III studies for patients carrying pathogenic SOD1 mutations (Roberts2022 pages 11-12).\\n\\nIn addition to antisense therapeutics, other therapeutic options for ALS have historically focused on slowing disease progression and providing symptomatic treatments to improve patient quality of life, including pain management, therapeutic exercise, and physiotherapy (Roberts2022 pages 9-10). Riluzole and edaravone are the only two drugs approved by the FDA for ALS treatment, with riluzole being the most widely used (Roberts2022 pages 9-10). However, their efficacy remains controversial, and more than 70 randomized drug trials in ALS patients have shown little beneficial effect on patient survival (Roberts2022 pages 9-10).\\n\\nWhile the article by Agrawal2022 does not provide information on available or being researched therapeutics for ALS in 2022, the article by Belgin2022 discusses past and future therapeutic strategies for the treatment of ALS, including pharmacological and non-pharmacological approaches, as well as emerging therapies such as gene therapy and stem cell therapy (Belgin2022 pages 1-1). The authors emphasize the multifaceted nature of ALS affected by many pathological mechanisms and the need for further research to develop effective treatments for ALS (Belgin2022 pages 1-1).\\n\\nThe article by Tereza2020 discusses various therapeutic approaches for ALS, including gene therapy, cell-based therapies, and neurotrophic factors (Tereza2020 pages 25-26). One gene therapy, VM202, has been shown to be safe and effective in reducing ALSFRS-R decline (Tereza2020 pages 25-26). Another compound, SynCav1, has shown promise in improving motor function and survival in preclinical ALS mouse models (Tereza2020 pages 25-26). Cell-based therapies, such as astrocyte-based therapies and the transplantation of human glial restricted progenitor cells, have also shown promise in preclinical and clinical trials (Tereza2020 pages 25-26). Kadimastem Ltd. has reported promising interim results in a Phase 1/2a clinical trial using AstroRx\\u00ae cells, which contain functional healthy astrocytes derived from human embryonic stem cells (Tereza2020 pages 25-26). A Phase 1/2a open-label study will also be initiated in 2020 to investigate the safety of the transplantation of human glial restricted progenitor cells into the spinal cord of ALS patients (Tereza2020 pages 25-26).\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"Roberts2022 pages 11-12\",\r\n        \"text\": \"B. Roberts, F. Theunissen, F. Mastaglia, P. Akkari, and L. L. Flynn. Synucleinopathy in amyotrophic lateral sclerosis: a potential avenue for antisense therapeutics? International Journal of Molecular Sciences, 2022.\"\r\n      },\r\n      {\r\n        \"key\": \"Roberts2022 pages 9-10\",\r\n        \"text\": \"B. Roberts, F. Theunissen, F. Mastaglia, P. Akkari, and L. L. Flynn. Synucleinopathy in amyotrophic lateral sclerosis: a potential avenue for antisense therapeutics? International Journal of Molecular Sciences, 2022.\"\r\n      },\r\n      {\r\n        \"key\": \"Agrawal2022 pages 22-22\",\r\n        \"text\": \"I. Agrawal, Yong Shan Lim, Shi\\u2010Yan Ng, and Shuo-Chien Ling. Deciphering lipid dysregulation in als: from mechanisms to translational medicine. Translational Neurodegeneration, 2022.\"\r\n      },\r\n      {\r\n        \"key\": \"Belgin2022 pages 1-1\",\r\n        \"text\": \"Belgin Sever, Halil I. Ciftci, H. Demirci, Hilal Sever, Firdevs Ocak, B. Yulug, Hiroshi Tateishi, T. Tateishi, M. Otsuka, M. Fujita, and A. Ba\\u015fak. Comprehensive research on past and future therapeutic strategies devoted to treatment of amyotrophic lateral sclerosis. International Journal of Molecular Sciences, 2022.\"\r\n      },\r\n      {\r\n        \"key\": \"Tereza2020 pages 25-26\",\r\n        \"text\": \"Tereza Filipi, Z. Hermanova, J. Tureckova, Ond\\u0159ej Va\\u0148\\u00e1tko, and M. And\\u011brov\\u00e1. Glial cells\\u2014the strategic targets in amyotrophic lateral sclerosis treatment. Journal of Clinical Medicine, 2020.\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"What materials and energy are required input to use microorganisms for synthesis of plastics?\",\r\n    \"model\": \"paperqa-1.1.1\",\r\n    \"date\": \"2023-04-11\",\r\n    \"answer\": \"I cannot answer\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"Urbanek7669 pages 8-8\",\r\n        \"text\": \"A. Urbanek, W. Rymowicz, and A. Miro\\u0144czuk. Degradation of plastics and plastic-degrading bacteria in cold marine habitats. Applied Microbiology and Biotechnology, 102:7669 - 7678, 2018.\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"What are promising targets for Alzheimer's disease (other than ABeta)\",\r\n    \"model\": \"paperqa-1.1.1\",\r\n    \"date\": \"2023-04-11\",\r\n    \"answer\": \"Several potential targets for Alzheimer's disease beyond ABeta have been identified in the literature. Hampel5481 pages 22-23 discusses genetic loci such as TREM2, SORL1, and ABCA7, as well as common variants at ABCA7, MS4A6A/MS4A4E, EPHA1, CD33, and CD2AP. Loss-of-function variants in ABCA7 are also mentioned as a risk factor for Alzheimer's disease. Additionally, the article discusses the importance of identifying preclinical stages of Alzheimer's disease and the potential use of amyloid positron emission tomography for staging beta-amyloid pathology. Chandra5424 pages 17-17 suggests that tau protein and neuroinflammation may be alternative targets for Alzheimer's disease, in addition to amyloid-beta, and cites several studies investigating the use of PET imaging to detect tau protein and neuroinflammation in patients with Alzheimer's disease and mild cognitive impairment. Chen2022 pages 4-5 mentions signaling pathways that induce cerebral blood flow, excessive synthesis of acetylcholinesterase (AChE), and decreased expression of low-density lipoprotein receptor-related protein-1 (LRP1) as potential targets for Alzheimer's disease treatment. The text suggests that targeting these pathways may help reduce the symptoms of Alzheimer's disease and prevent amyloid accumulation in the brain. However, Jens2013 pages 9-9 does not provide specific information on other potential targets.\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"Jens2013 pages 1-1\",\r\n        \"text\": \"Jens Moreth, Chrystelle Mavoungou, and K. Schindowski. Passive anti-amyloid immunotherapy in alzheimer's disease: what are the most promising targets? Immunity & Ageing : I & A, 10:18 - 18, 2013.\"\r\n      },\r\n      {\r\n        \"key\": \"Hampel5481 pages 22-23\",\r\n        \"text\": \"H. Hampel, J. Hardy, Kaj Blennow, Christopher Chen, George Perry, S. H. Kim, V. Villemagne, P. Aisen, M. Vendruscolo, T. Iwatsubo, C. Masters, M. Cho, L. Lannfelt, J. L. Cummings, and A. Vergallo. The amyloid-\\u03b2 pathway in alzheimer\\u2019s disease. Molecular Psychiatry, 26:5481 - 5503, 2021.\"\r\n      },\r\n      {\r\n        \"key\": \"Chandra5424 pages 17-17\",\r\n        \"text\": \"A. Chandra, Polytimi-Eleni Valkimadi, G. Pagano, O. Cousins, G. Dervenoulas, and M. Politis. Applications of amyloid, tau, and neuroinflammation pet imaging to alzheimer's disease and mild cognitive impairment. Human Brain Mapping, 40:5424 - 5442, 2019.\"\r\n      },\r\n      {\r\n        \"key\": \"Chen2022 pages 4-5\",\r\n        \"text\": \"Chen Ma, Fenfang Hong, and Shulong Yang. Amyloidosis in alzheimer\\u2019s disease: pathogeny, etiology, and related therapeutic directions. Molecules, 2022.\"\r\n      },\r\n      {\r\n        \"key\": \"Jens2013 pages 9-9\",\r\n        \"text\": \"Jens Moreth, Chrystelle Mavoungou, and K. Schindowski. Passive anti-amyloid immunotherapy in alzheimer's disease: what are the most promising targets? Immunity & Ageing : I & A, 10:18 - 18, 2013.\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"What methods can be used to explain predictions from black box models in chemistry?\",\r\n    \"model\": \"paperqa-1.1.1\",\r\n    \"date\": \"2023-04-11\",\r\n    \"answer\": \"The text proposes a universal model-agnostic approach that can explain any black-box model prediction in chemistry (Geemi3697 pages 1-1). This approach includes the use of counterfactuals as a category of explanations that provide a rationale behind a model prediction with satisfying properties like providing chemical structure insights. The authors demonstrate the effectiveness of this approach on random forest models, sequence models, and graph neural networks in both classification and regression tasks (Geemi3697 pages 1-1). Additionally, the text mentions Miller's proposed nomenclature within XAI that distinguishes between a prediction explanation, interpretability of a model, and prediction justification (Geemi3697 pages 1-1).\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"Geemi3697 pages 1-1\",\r\n        \"text\": \"Geemi P. Wellawatte, Aditi Seshadri, and A. White. Model agnostic generation of counterfactual explanations for molecules. Chemical Science, 13:3697 - 3705, 2021.\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"Why do birds flock?\",\r\n    \"model\": \"paperqa-1.1.1\",\r\n    \"date\": \"2023-04-11\",\r\n    \"answer\": \"Birds flock for a variety of reasons, including social, navigational, and anti-predator implications (Usherwood2011). Flying in a flock can result in aerodynamic benefits, reducing power requirements, as demonstrated by a reduction in heart rate and wingbeat frequency in pelicans flying in a V-formation (Usherwood2011). However, the aerodynamic consequences of flying in the more usual \\u2018cluster\\u2019 flock are not well understood (Usherwood2011). The main goal of the interaction among birds in a flock is to maintain cohesion of the aggregation, which is a strong biological requirement shaped by the evolutionary pressure for survival (Ballerini1232). Stragglers and small groups are significantly more prone to predation than animals belonging to large and highly cohesive aggregations (Ballerini1232). The vast majority of models, both developed by physicists and biologists, adopt a definition of \\u2018distance\\u2019 that is the same as in physics, i.e. metric distance, and animals can estimate metric distance in various ways, including stereovision, retinal image size, and optic flow (Ballerini1232). The variability of shape in bird flocks increases when there are larger local differences in movement behavior in the flock, which happens when flock size is larger, interacting partners are fewer, the flock turnings are stronger, and individuals roll into the turn (Hemelrijk2011). A major benefit of bird flocking behavior is that it increases collective vigilance and allows for early detection of attacking predators, which relies on rapid transfer of information about danger from the individual first detecting the predator (Mae4173). Acoustic signals or cues of danger are likely to be particularly effective, as information is passed rapidly to all nearby members of a group, and can be detected even if a bird is not currently vigilant or is out of sight (Mae4173). Flocks self-organize to the maximum density at which a typical individual is still just able to see out of the flock in many directions, which provides for faster information transfer and hence rapid flock dynamics, an advantage over local models (Pearce1042). It optimizes the information available to each bird while maintaining the protection of a dense, coherent flock (Pearce1042).\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"Usherwood2011 pages 1-1\",\r\n        \"text\": \"J. Usherwood, Marinos Stavrou, J. Lowe, K. Roskilly, and Alan M. Wilson. Flying in a flock comes at a cost in pigeons. Nature, 474:494 - 497, 2011.\"\r\n      },\r\n      {\r\n        \"key\": \"Ballerini1232 pages 2-3\",\r\n        \"text\": \"M. Ballerini, N. Cabibbo, R. Candelier, A. Cavagna, E. Cisbani, I. Giardina, V. Lecomte, A. Orlandi, G. Parisi, A. Procaccini, M. Viale, and V. Zdravkovic. Interaction ruling animal collective behavior depends on topological rather than metric distance: evidence from a field study. Proceedings of the National Academy of Sciences, 105:1232 - 1237, 2007.\"\r\n      },\r\n      {\r\n        \"key\": \"Hemelrijk2011 pages 1-1\",\r\n        \"text\": \"C. Hemelrijk and H. Hildenbrandt. Some causes of the variable shape of flocks of birds. PLoS ONE, 2011.\"\r\n      },\r\n      {\r\n        \"key\": \"Mae4173 pages 1-1\",\r\n        \"text\": \"Mae Hingee and R. Magrath. Flights of fear: a mechanical wing whistle sounds the alarm in a flocking bird. Proceedings of the Royal Society B: Biological Sciences, 276:4173 - 4179, 2009.\"\r\n      },\r\n      {\r\n        \"key\": \"Pearce1042 pages 1-1\",\r\n        \"text\": \"D. Pearce, A. M. Miller, G. Rowlands, and M. S. Turner. Role of projection in the control of bird flocks. Proceedings of the National Academy of Sciences, 111:10422 - 10426, 2014.\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"What methods can be used to explain predictions from black box models in chemistry?\",\r\n    \"model\": \"paperqa-1.2.0\",\r\n    \"date\": \"2023-04-26\",\r\n    \"answer\": \"The paper by Geemi et al. (2021) discusses several model-agnostic approaches for explaining predictions from black box models in chemistry, including identifying which features contribute the most, identifying which training data contributes the most, fitting a locally interpretable model around the prediction, and providing contrastive or counterfactual points. The paper also mentions feature importance analysis and local interpretable model-agnostic explanations (LIME), which provide per-feature weights that identify how each feature contributed to the final prediction. Geemi et al. (2021) also introduce a model-agnostic visualization tool named CIME for XAI based on feature attribution, which uses SHAP values and Class Attribution Maps (CAM) to compute feature/atomic attributions. Additionally, the paper discusses a model-agnostic method called MMACE for generating counterfactual explanations for molecules. However, the paper does not mention any other methods for explaining predictions from black box models in chemistry. Philip (2016) also discusses the top-ranked features for auditing black-box models on various datasets, including the Dark Reactions data in chemistry. The top-ranked features for the three models include the minimum Pauling electronegativity and the maximum Pearson electronegativity in the top-ranked cluster of features. The SVM and FNN top features include atomic properties of the inorganics that are related to the electronegativity of an element, so these proxies are correctly also highly ranked. The top-ranked decision tree features additionally include the average molecular polarizability for the organic components, which was previously hypothesized.\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"Geemi3697 pages 1-2\",\r\n        \"text\": \"Geemi P Wellawatte, Aditi Seshadri, and A. White. Model agnostic generation of counterfactual explanations for molecules. Chemical Science, 13:3697 - 3705, 2021.\"\r\n      },\r\n      {\r\n        \"key\": \"Geemi3697 pages 4-5\",\r\n        \"text\": \"Geemi P Wellawatte, Aditi Seshadri, and A. White. Model agnostic generation of counterfactual explanations for molecules. Chemical Science, 13:3697 - 3705, 2021.\"\r\n      },\r\n      {\r\n        \"key\": \"Geemi3697 pages 8-9\",\r\n        \"text\": \"Geemi P Wellawatte, Aditi Seshadri, and A. White. Model agnostic generation of counterfactual explanations for molecules. Chemical Science, 13:3697 - 3705, 2021.\"\r\n      },\r\n      {\r\n        \"key\": \"Philip2016 pages 5-6\",\r\n        \"text\": \"Philip Adler, Casey Falk, Sorelle A. Friedler, Tionney Nix, Gabriel Rybeck, C. Scheidegger, Brandon Smith, and Suresh Venkatasubramanian. Auditing black-box models for indirect influence. Knowledge and Information Systems, 54:95-122, 2016.\"\r\n      }\r\n    ]\r\n  },{\r\n    \"question\": \"Why do birds flock?\",\r\n    \"model\": \"paperqa-1.2.0\",\r\n    \"date\": \"2023-04-26\",\r\n    \"answer\": \"The provided sources do not directly state the reasons why birds flock. However, they do provide insights into the collective behavior of bird flocks. Nagy et al. (2010) found that there is a well-defined hierarchy among flock members based on their leading roles in pairwise interactions, and that the average spatial position of a pigeon within the flock strongly correlates with its place in the hierarchy. Cavagna et al. (2010) provided experimental evidence that bird flocks exhibit scale-free correlations, which means that the group cannot be divided into independent sub-parts, and the effective perception range of each individual is as large as the entire group. Attanasi et al. (2014) suggested that the adaptive drive for the high degree of order observed in many living groups may be to achieve a fast and robust collective decision. Ballerini et al. (2008) argued that topological interaction, rather than metric interaction, is the only mechanism that can grant robust cohesion and higher biological fitness. Bialek et al. (2012) found that interactions among neighboring birds in a flock cause an alignment of their flight directions, and the entire flock spontaneously chooses a unique direction in which to fly.\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"Nagy2010 pages 1-1\",\r\n        \"text\": \"M. Nagy, Zsuzsa \\u00c1kos, D. Biro, and T. Vicsek. Hierarchical group dynamics in pigeon flocks. Nature, 464:890-893, 2010.\"\r\n      },\r\n      {\r\n        \"key\": \"Cavagna1186 pages 3-4\",\r\n        \"text\": \"A. Cavagna, A. Cimarelli, I. Giardina, G. Parisi, Raffaele Santagati, F. Stefanini, and M. Viale. Scale-free correlations in starling flocks. Proceedings of the National Academy of Sciences, 107:11865 - 11870, 2009.\"\r\n      },\r\n      {\r\n        \"key\": \"Attanasi2014 pages 7-8\",\r\n        \"text\": \"A. Attanasi, A. Cavagna, L. Del Castello, I. Giardina, T. Grigera, A. Jelic, S. Melillo, L. Parisi, O. Pohl, E. Shen, and M. Viale. Information transfer and behavioural inertia in starling flocks. Nature physics, 10:615 - 698, 2014.\"\r\n      },\r\n      {\r\n        \"key\": \"Ballerini1232 pages 6-7\",\r\n        \"text\": \"M. Ballerini, N. Cabibbo, R. Candelier, A. Cavagna, E. Cisbani, I. Giardina, V. Lecomte, A. Orlandi, G. Parisi, A. Procaccini, M. Viale, and V. Zdravkovic. Interaction ruling animal collective behavior depends on topological rather than metric distance: evidence from a field study. Proceedings of the National Academy of Sciences, 105:1232 - 1237, 2007.\"\r\n      },\r\n      {\r\n        \"key\": \"Bialek4786 pages 1-1\",\r\n        \"text\": \"W. Bialek, A. Cavagna, I. Giardina, T. Mora, Edmondo Silvestri, M. Viale, and A. Walczak. Statistical mechanics for natural flocks of birds. Proceedings of the National Academy of Sciences, 109:4786 - 4791, 2011.\"\r\n      }\r\n    ]\r\n  },{\r\n    \"question\": \"What are promising targets for Alzheimer's disease (other than ABeta)\",\r\n    \"model\": \"paperqa-1.2.0\",\r\n    \"date\": \"2023-04-26\",\r\n    \"answer\": \"There are several potential targets for Alzheimer's disease treatment beyond ABeta. Abyadeh1964 suggests that CRMP2 hyperphosphorylation, the Wnt/beta-catenin pathway, and PPAR alpha and gamma agonists are potential targets. Pioglitazone, a PPAR gamma agonist, has shown promise in clinical trials. Hampel5481 discusses various enzymes and proteins that have potential as therapeutic targets, including the secretases, gamma-secretase heterogeneity in the Aph1 subunit, Presenilin-1, ADAM10, and the secreted amyloid precursor protein ectodomain APPs alpha. Bronzuoli2016 suggests reducing neuroinflammation and inhibiting reactive gliosis as potential targets, with specific examples of potential treatments including minocycline, sirtuin modulators, B2 receptor blockers, glaucocalyxin B, palmitoylethanolamide, and S100B inhibitors. However, there is no consensus on which targets are most promising for Alzheimer's disease treatment. (Abyadeh1964 pages 13-13, Abyadeh1964 pages 2-3, Hampel5481 pages 17-17, Bronzuoli2016 pages 9-10)\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"Jens2013 pages 1-1\",\r\n        \"text\": \"Jens Moreth, Chrystelle Mavoungou, and K. Schindowski. Passive anti-amyloid immunotherapy in alzheimer's disease: what are the most promising targets? Immunity & Ageing : I & A, 10:18 - 18, 2013.\"\r\n      },\r\n      {\r\n        \"key\": \"Abyadeh1964 pages 13-13\",\r\n        \"text\": \"M. Abyadeh, Vivek Gupta, Veer Bala Gupta, Nitin Chitranshi, Yunqi Wu, A. Amirkhani, A. Meyfour, Samran Sheriff, Ting Shen, Kunal Dhiman, G. Salekdeh, P. Haynes, S. Graham, and M. Mirzaei. Comparative analysis of aducanumab, zagotenemab and pioglitazone as targeted treatment strategies for alzheimer\\u2019s disease. Aging and Disease, 12:1964 - 1976, 2021.\"\r\n      },\r\n      {\r\n        \"key\": \"Abyadeh1964 pages 2-3\",\r\n        \"text\": \"M. Abyadeh, Vivek Gupta, Veer Bala Gupta, Nitin Chitranshi, Yunqi Wu, A. Amirkhani, A. Meyfour, Samran Sheriff, Ting Shen, Kunal Dhiman, G. Salekdeh, P. Haynes, S. Graham, and M. Mirzaei. Comparative analysis of aducanumab, zagotenemab and pioglitazone as targeted treatment strategies for alzheimer\\u2019s disease. Aging and Disease, 12:1964 - 1976, 2021.\"\r\n      },\r\n      {\r\n        \"key\": \"Hampel5481 pages 17-17\",\r\n        \"text\": \"H. Hampel, J. Hardy, Kaj Blennow, Christopher Chen, George Perry, S. H. Kim, V. Villemagne, P. Aisen, M. Vendruscolo, T. Iwatsubo, C. Masters, M. Cho, L. Lannfelt, J. L. Cummings, and A. Vergallo. The amyloid-\\u03b2 pathway in alzheimer\\u2019s disease. Molecular Psychiatry, 26:5481 - 5503, 2021.\"\r\n      },\r\n      {\r\n        \"key\": \"Bronzuoli2016 pages 9-10\",\r\n        \"text\": \"M. R. Bronzuoli, A. Iacomino, L. Steardo, and C. Scuderi. Targeting neuroinflammation in alzheimer\\u2019s disease. Journal of Inflammation Research, 9:199 - 208, 2016.\"\r\n      }\r\n    ]\r\n  },{\r\n    \"question\": \"Are SELFIEs or SMILES a better representation of molecules for deep learning?\",\r\n    \"model\": \"paperqa-1.2.0\",\r\n    \"date\": \"2023-04-26\",\r\n    \"answer\": \"The choice between SELFIEs and SMILES as a representation of molecules for deep learning depends on the specific application and available resources (Akshat7079 pages 12-12). While SELFIEs are more expressive and can represent a larger chemical space than SMILES (Akshat7079 pages 12-12), they are also more computationally expensive and require more memory (Akshat7079 pages 12-12). SELFIEs allow for efficient algorithms to perform exploration and interpolation in the chemical space without the need for extensive training times, large datasets, and hand-crafted rules for obtaining novel molecules (Akshat7079 pages 1-2). However, the text does not provide a direct comparison of the advantages and disadvantages of using SELFIEs and SMILES representations for deep learning in molecular modeling (Akshat7079 pages 4-4, 8-9). Therefore, it is difficult to determine which representation is better for deep learning without further research.\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"Akshat7079 pages 5-6\",\r\n        \"text\": \"AkshatKumar Nigam, R. Pollice, M. Krenn, Gabriel dos Passos Gomes, and Al\\u00e1n Aspuru-Guzik. Beyond generative models: superfast traversal, optimization, novelty, exploration and discovery (stoned) algorithm for molecules using selfies\\u2020. Chemical Science, 12:7079 - 7090, 2020.\"\r\n      },\r\n      {\r\n        \"key\": \"Akshat7079 pages 1-2\",\r\n        \"text\": \"AkshatKumar Nigam, R. Pollice, M. Krenn, Gabriel dos Passos Gomes, and Al\\u00e1n Aspuru-Guzik. Beyond generative models: superfast traversal, optimization, novelty, exploration and discovery (stoned) algorithm for molecules using selfies\\u2020. Chemical Science, 12:7079 - 7090, 2020.\"\r\n      },\r\n      {\r\n        \"key\": \"Akshat7079 pages 12-12\",\r\n        \"text\": \"AkshatKumar Nigam, R. Pollice, M. Krenn, Gabriel dos Passos Gomes, and Al\\u00e1n Aspuru-Guzik. Beyond generative models: superfast traversal, optimization, novelty, exploration and discovery (stoned) algorithm for molecules using selfies\\u2020. Chemical Science, 12:7079 - 7090, 2020.\"\r\n      },\r\n      {\r\n        \"key\": \"Akshat7079 pages 4-4\",\r\n        \"text\": \"AkshatKumar Nigam, R. Pollice, M. Krenn, Gabriel dos Passos Gomes, and Al\\u00e1n Aspuru-Guzik. Beyond generative models: superfast traversal, optimization, novelty, exploration and discovery (stoned) algorithm for molecules using selfies\\u2020. Chemical Science, 12:7079 - 7090, 2020.\"\r\n      },\r\n      {\r\n        \"key\": \"Akshat7079 pages 8-9\",\r\n        \"text\": \"AkshatKumar Nigam, R. Pollice, M. Krenn, Gabriel dos Passos Gomes, and Al\\u00e1n Aspuru-Guzik. Beyond generative models: superfast traversal, optimization, novelty, exploration and discovery (stoned) algorithm for molecules using selfies\\u2020. Chemical Science, 12:7079 - 7090, 2020.\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"How do Salamanders breathe?\",\r\n    \"model\": \"paperqa-1.2.0\",\r\n    \"date\": \"2023-04-26\",\r\n    \"answer\": \"Salamanders have evolved diverse respiratory systems for acquiring oxygen from the environment, including skin, gills, and lungs that may coexist within the same species (Hsia2013 pages 1-1). Cutaneous gas exchange is enhanced by erythrocyte fragmentation in salamanders that possess large erythrocytes (Hsia2013 pages 35-36). The text does not provide specific information about whether salamanders use their skin, lungs, or other structures for breathing (Hsia2013 pages 34-35). However, in lung-breathing tetrapods, the respiratory apparatus consists of a gas-exchanger intimately connected to a passive pump, an active pump containing the respiratory musculature, and a central nervous control element that coordinates pump activity and optimizes the function of the gas exchanger. The gas exchanger communicates with the CNCE mainly via circulation, using blood pH and O2 saturation to regulate the frequency and amplitude of active ventilation. The structure of amniote gas-exchange tissue is superficially similar to that in lungfish or lissamphibians (Hsia2013 pages 35-36).\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"Hsia2013 pages 35-36\",\r\n        \"text\": \"C. Hsia, A. Schmitz, M. Lambertz, S. Perry, and J. Maina. Evolution of air breathing: oxygen homeostasis and the transitions from water to land and sky. Comprehensive Physiology, 3 2:849-915, 2013.\"\r\n      },\r\n      {\r\n        \"key\": \"Hsia2013 pages 1-1\",\r\n        \"text\": \"C. Hsia, A. Schmitz, M. Lambertz, S. Perry, and J. Maina. Evolution of air breathing: oxygen homeostasis and the transitions from water to land and sky. Comprehensive Physiology, 3 2:849-915, 2013.\"\r\n      },\r\n      {\r\n        \"key\": \"Hsia2013 pages 34-35\",\r\n        \"text\": \"C. Hsia, A. Schmitz, M. Lambertz, S. Perry, and J. Maina. Evolution of air breathing: oxygen homeostasis and the transitions from water to land and sky. Comprehensive Physiology, 3 2:849-915, 2013.\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"What do bispecific CD38 antibodies bind to and how do they treat myeloma?\",\r\n    \"model\": \"paperqa-1.2.0\",\r\n    \"date\": \"2023-04-26\",\r\n    \"answer\": \"Bispecific CD38 antibodies bind to CD38, a transmembrane glycoprotein expressed on the surface of multiple myeloma (MM) cells, and CD3, a T cell receptor. This binding leads to the activation of T cells and the subsequent killing of MM cells (Chiara2020 pages 14-14). Bispecific CD38 antibodies, such as GBR1342, engage T cells to kill myeloma cells (Chiara2020 pages 23-23). Bispecific CAR-T cells that target both CD38 and BCMA are designed to bind to both CD38 and BCMA, leading to the destruction of the cancer cells (Tang2022 pages 15-15). Bispecific CD38 antibodies can also bind to another target, such as CD47, to induce phagocytosis of myeloma cells (Donk2018 pages 9-9). Overall, bispecific CD38 antibodies treat myeloma by recruiting T-cells to target and kill myeloma cells (Xiang2020 pages 11-11).\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"Chiara2020 pages 14-14\",\r\n        \"text\": \"Chiara Caraccio, Sachi Krishna, D. Phillips, and C. Sch\\u00fcrch. Bispecific antibodies for multiple myeloma: a review of targets, drugs, clinical trials, and future directions. Frontiers in Immunology, 2020.\"\r\n      },\r\n      {\r\n        \"key\": \"Tang2022 pages 15-15\",\r\n        \"text\": \"Y. Tang, Haisen Yin, Xinying Zhao, D. Jin, Yan Liang, Tao Xiong, Lu Li, W. Tang, Jiangzhao Zhang, Min Liu, Zhuojun Yu, Huimin Liu, Sibin Zang, and Zhiping Huang. High efficacy and safety of cd38 and bcma bispecific car-t in relapsed or refractory multiple myeloma. Journal of Experimental & Clinical Cancer Research : CR, 2022.\"\r\n      },\r\n      {\r\n        \"key\": \"Chiara2020 pages 23-23\",\r\n        \"text\": \"Chiara Caraccio, Sachi Krishna, D. Phillips, and C. Sch\\u00fcrch. Bispecific antibodies for multiple myeloma: a review of targets, drugs, clinical trials, and future directions. Frontiers in Immunology, 2020.\"\r\n      },\r\n      {\r\n        \"key\": \"Donk2018 pages 9-9\",\r\n        \"text\": \"N. V. D. van de Donk and S. Usmani. Cd38 antibodies in multiple myeloma: mechanisms of action and modes of resistance. Frontiers in Immunology, 2018.\"\r\n      },\r\n      {\r\n        \"key\": \"Xiang2020 pages 11-11\",\r\n        \"text\": \"Xiang Zhou, H. Einsele, and S. Danhof. Bispecific antibodies: a new era of treatment for multiple myeloma. Journal of Clinical Medicine, 2020.\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"What materials and energy are required input to use microorganisms for synthesis of plastics?\",\r\n    \"model\": \"paperqa-1.2.0\",\r\n    \"date\": \"2023-04-26\",\r\n    \"answer\": \"Insufficient information is provided in the sources to answer this question directly. While the sources discuss the use of microorganisms, specifically cyanobacteria, for the synthesis of biodegradable plastics, they do not provide specific information on the materials and energy required for microorganisms to synthesize plastics. However, the sources do mention the potential of using renewable raw materials and atmospheric CO2 as sources of carbon for the production of bioplastics, as well as the use of organic substrates and energy-intensive procedures for fermentation and PHA extraction. Genetic engineering is also mentioned as a technique to improve the production of biopolymers in microorganisms. Further research is needed to determine the specific materials and energy requirements for microorganisms to synthesize plastics.\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"Urbanek7669 pages 8-8\",\r\n        \"text\": \"A. Urbanek, W. Rymowicz, and A. Miro\\u0144czuk. Degradation of plastics and plastic-degrading bacteria in cold marine habitats. Applied Microbiology and Biotechnology, 102:7669 - 7678, 2018.\"\r\n      },\r\n      {\r\n        \"key\": \"Preeti2022 pages 4-4\",\r\n        \"text\": \"Preeti Agarwal, R. Soni, Pritam Kaur, Akanksha Madan, Reema Mishra, Jayati Pandey, Shreya Singh, and Garvita Singh. Cyanobacteria as a promising alternative for sustainable environment: synthesis of biofuel and biodegradable plastics. Frontiers in Microbiology, 2022.\"\r\n      },\r\n      {\r\n        \"key\": \"Preeti2022 pages 2-2\",\r\n        \"text\": \"Preeti Agarwal, R. Soni, Pritam Kaur, Akanksha Madan, Reema Mishra, Jayati Pandey, Shreya Singh, and Garvita Singh. Cyanobacteria as a promising alternative for sustainable environment: synthesis of biofuel and biodegradable plastics. Frontiers in Microbiology, 2022.\"\r\n      },\r\n      {\r\n        \"key\": \"Preeti2022 pages 14-15\",\r\n        \"text\": \"Preeti Agarwal, R. Soni, Pritam Kaur, Akanksha Madan, Reema Mishra, Jayati Pandey, Shreya Singh, and Garvita Singh. Cyanobacteria as a promising alternative for sustainable environment: synthesis of biofuel and biodegradable plastics. Frontiers in Microbiology, 2022.\"\r\n      },\r\n      {\r\n        \"key\": \"Preeti2022 pages 23-23\",\r\n        \"text\": \"Preeti Agarwal, R. Soni, Pritam Kaur, Akanksha Madan, Reema Mishra, Jayati Pandey, Shreya Singh, and Garvita Singh. Cyanobacteria as a promising alternative for sustainable environment: synthesis of biofuel and biodegradable plastics. Frontiers in Microbiology, 2022.\"\r\n      },\r\n      {\r\n        \"key\": \"Preeti2022 pages 21-22\",\r\n        \"text\": \"Preeti Agarwal, R. Soni, Pritam Kaur, Akanksha Madan, Reema Mishra, Jayati Pandey, Shreya Singh, and Garvita Singh. Cyanobacteria as a promising alternative for sustainable environment: synthesis of biofuel and biodegradable plastics. Frontiers in Microbiology, 2022.\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"How can carbon nanotubes be manufactured at scale?\",\r\n    \"model\": \"paperqa-1.2.0\",\r\n    \"date\": \"2023-04-26\",\r\n    \"answer\": \"Carbon nanotubes can be manufactured at scale using the Langmuir-Blodgett (LB) method, which achieves monolayers of aligned non-covalently functionalized single-walled carbon nanotubes (SWNTs) from organic solvent with dense packing. The monolayer SWNTs can be patterned for device integration by microfabrication, enabling the high currents (~3mA) SWNT devices with narrow channel widths. The method is generic for different bulk materials with various diameters (Xiaoling4890 pages 1-1). Another method for producing graphene nanoribbons (GNRs) is by unzipping the side walls of multi-walled carbon nanotubes (MWCNTs) using intercalation with suitable ions. The intertube intercalation of CNTs by different ions has been shown to be an effective method to decrease the van der Waals interactions between individual tubes and assist the exfoliation of bundled CNTs. By selecting appropriate neutral molecules or ions to substitute H2SO4 as an intercalation agent, it shall be a promising approach to produce GNRs with a high yield and further reduce the usage of strong acid during the nanotube unzipping (Yan2016 pages 1-2). Additionally, a green and scalable method for the synthesis of graphene nanoribbons is by intercalation-assisted longitudinal unzipping of multi-walled carbon nanotubes (MWCNTs) with KNO3 and H2SO4, which decreases the strong van der Waals attractions in the MWCNTs bundles and between the coaxial graphene walls of CNTs. The developed methodology possesses the ability to synthesize GNRs effectively with an improved CNT concentration in H2SO4 of 10 mg/ml at 70 \\u00b0C, which is amenable to industrial-scale production because of the decreased amount of strong acid (Yan2016 pages 1-1). The LB assembly of densely aligned SWNTs can be combined with chemical separation and selective chemical reaction methods to afford purely metallic or semiconducting SWNTs in massive parallel configuration useful for interconnection or high-speed transistor applications at large scale (Xiaoling4890 pages 2-2).\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"Xiaoling4890 pages 1-1\",\r\n        \"text\": \"Xiaoling Li, Li Zhang, Xinran Wang, I. Shimoyama, Xiaoming Sun, W. Seo, and H. Dai. Langmuir-blodgett assembly of densely aligned single-walled carbon nanotubes from bulk materials. Journal of the American Chemical Society, 129 16:4890-1, 2007.\"\r\n      },\r\n      {\r\n        \"key\": \"Yan2016 pages 1-2\",\r\n        \"text\": \"Yan-sheng Li, Jia-Liang Liao, Shan-Yu Wang, and Wei\\u2010Hung Chiang. Intercalation-assisted longitudinal unzipping of carbon nanotubes for green and scalable synthesis of graphene nanoribbons. Scientific Reports, 2016.\"\r\n      },\r\n      {\r\n        \"key\": \"Yan2016 pages 1-1\",\r\n        \"text\": \"Yan-sheng Li, Jia-Liang Liao, Shan-Yu Wang, and Wei\\u2010Hung Chiang. Intercalation-assisted longitudinal unzipping of carbon nanotubes for green and scalable synthesis of graphene nanoribbons. Scientific Reports, 2016.\"\r\n      },\r\n      {\r\n        \"key\": \"Yan2016 pages 11-11\",\r\n        \"text\": \"Yan-sheng Li, Jia-Liang Liao, Shan-Yu Wang, and Wei\\u2010Hung Chiang. Intercalation-assisted longitudinal unzipping of carbon nanotubes for green and scalable synthesis of graphene nanoribbons. Scientific Reports, 2016.\"\r\n      },\r\n      {\r\n        \"key\": \"Xiaoling4890 pages 2-2\",\r\n        \"text\": \"Xiaoling Li, Li Zhang, Xinran Wang, I. Shimoyama, Xiaoming Sun, W. Seo, and H. Dai. Langmuir-blodgett assembly of densely aligned single-walled carbon nanotubes from bulk materials. Journal of the American Chemical Society, 129 16:4890-1, 2007.\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"What therapeutics are available or being researched for ALS as of 2022?\",\r\n    \"model\": \"paperqa-1.2.0\",\r\n    \"date\": \"2023-04-26\",\r\n    \"answer\": \"As of 2022, only symptomatic treatments are available for ALS, and disease-modifying therapies have been elusive despite over 70 randomized trials of putative new therapeutic agents over the past two decades (Roberts2022 pages 14-15). Pain management, therapeutic exercise, and physiotherapy are recommended to alleviate pain and slow symptomatic progression (Roberts2022 pages 9-10). Riluzole and edaravone are the only two drugs approved by the FDA for ALS treatment, with riluzole being the most widely used, but their efficacy remains controversial (Roberts2022 pages 9-10). Antisense therapeutics targeting synucleinopathy in ALS are being researched as a potential avenue for treatment (Roberts2022 pages 9-10). Two RNA-based therapeutics, jacifusen for FUS and tofersen for SOD1, are being researched for ALS as of 2022, with tofersen currently in a phase III trial showing signs of slowing disease progression in patients with SOD1-ALS (Anja2022 pages 8-8). However, further research is required to provide a clearer understanding of synucleinopathy development in various ALS patient groups, at different stages of the disease process, as well as further investigation of the interactions between Syn and other ALS-associated proteins across the spectrum of neurodegenerative diseases (Roberts2022 pages 14-15). Additionally, various potential therapeutic targets for ALS are being researched, including astrocytes, neuronal cholesterol synthesis, oligodendroglial myelination, NAD+ precursors and antioxidants, SIRT3 activation, and gut microbiome and metabolites (Agrawal2022 pages 27-27).\",\r\n    \"sources\": [\r\n      {\r\n        \"key\": \"Roberts2022 pages 14-15\",\r\n        \"text\": \"B. Roberts, F. Theunissen, F. Mastaglia, P. Akkari, and L. L. Flynn. Synucleinopathy in amyotrophic lateral sclerosis: a potential avenue for antisense therapeutics? International Journal of Molecular Sciences, 2022.\"\r\n      },\r\n      {\r\n        \"key\": \"Roberts2022 pages 9-10\",\r\n        \"text\": \"B. Roberts, F. Theunissen, F. Mastaglia, P. Akkari, and L. L. Flynn. Synucleinopathy in amyotrophic lateral sclerosis: a potential avenue for antisense therapeutics? International Journal of Molecular Sciences, 2022.\"\r\n      },\r\n      {\r\n        \"key\": \"Anja2022 pages 1-1\",\r\n        \"text\": \"Anja Holm, Stine N Hansen, H. Klitgaard, and S. Kauppinen. Clinical advances of rna therapeutics for treatment of neurological and neuromuscular diseases. RNA Biology, 19:594 - 608, 2022.\"\r\n      },\r\n      {\r\n        \"key\": \"Anja2022 pages 8-8\",\r\n        \"text\": \"Anja Holm, Stine N Hansen, H. Klitgaard, and S. Kauppinen. Clinical advances of rna therapeutics for treatment of neurological and neuromuscular diseases. RNA Biology, 19:594 - 608, 2022.\"\r\n      },\r\n      {\r\n        \"key\": \"Agrawal2022 pages 27-27\",\r\n        \"text\": \"I. Agrawal, Yong Shan Lim, Shi\\u2010Yan Ng, and Shuo-Chien Ling. Deciphering lipid dysregulation in als: from mechanisms to translational medicine. Translational Neurodegeneration, 2022.\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"question\": \"What factors should I consider for selecting a catalyst for a Diels-Alder reaction?\",\r\n    \"model\": \"paperqa-1.2.0\",\r\n    \"date\": \"2023-04-26\",\r\n    \"answer\": \"I cannot answer\",\r\n    \"sources\": []\r\n  }\r\n];","<script>\n\timport AnswerGroup from \"./AnswerGroup.svelte\";\n\timport data from \"./data.js\";\n\t// first strip https off model names\n\tdata.forEach((d) => {\n\t\td.model = d.model.replace(\"https://\", \"\");\n\t})\n\tlet questions = new Set(data.map((m) => m.question));\n\tlet models = new Set(data.map((m) => m.model.split(\"-\")[0]));\n\tlet selectedQuestion = questions.values().next().value;\n\tlet groupedAnswers = Object()\n\tquestions.forEach((q) => models.forEach((m) => {\n\t\tif (groupedAnswers[q] === undefined)\n\t\t\tgroupedAnswers[q] = []\n\t\tconst a = data.flatMap((e) => {\n\t\t\tif(e.question === q && e.model.split(\"-\")[0] === m)\n\t\t\t\treturn e\n\t\t}).filter((e) => e !== undefined)\n\t\tif (a.length > 0)\n\t\t\tgroupedAnswers[q].push(a);\n\t}))\n</script>\n<main>\n\t<h1 class=\"hero\">qa_bench</h1>\n\t<div>by andrew white</div>\n\t<div class=\"question-container\">\n\t  <select bind:value={selectedQuestion}>\n\t\t{#each [...questions] as question, index}\n\t\t  <option value={question}>Q{index + 1}</option>\n\t\t{/each}\n\t  </select>\n\t  <p class=\"question\">{selectedQuestion}</p>\n\t</div>\n\t<div class=\"answer-grid\">\n\t  {#each groupedAnswers[selectedQuestion].filter((g) => g.length > 0) as group}\n\t\t<AnswerGroup group={group} />\n\t  {/each}\n\t</div>\n  </main>\n\n<style>\n\tmain {\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t\talign-items: center;\n\t}\n\n\t.hero {\n\t\tfont-size: 40px;\n\t\tmargin: 20px;\n\t}\n\n\t.answer-grid {\n\t\tdisplay: flex;\n\t\talign-items: flex-start;\n\t\tgrid-gap: 20px;\n\t\twidth: 80%;\n\t\tmargin-bottom: 2rem;\n\t}\n\t\n\t\n\t.question {\n\t\tfont-size: 1.5em;\n\t\tmargin-left: 10px;\n\t}\n\n\t.question-container {\n\t\tdisplay: flex;\n\t\talign-items: center;\n\t}\n\n\t@media (max-width: 900px) {\n\t\t.question-container {\n\t\t\tflex-direction: column;\n\t\t\tmargin-top: 1rem;\n\t\t}\n\n\t\t.answer-grid {\n\t\t\twidth: 90%;\n\t\t\tdisplay: grid;\n\t\t}\n\t}\n\n</style>\n","import App from './App.svelte';\nconst app = new App({\n\ttarget: document.body,\n});\n\nexport default app;"],"names":["noop","identity","x","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","is_client","window","now","performance","Date","raf","cb","requestAnimationFrame","tasks","Set","run_tasks","task","c","delete","f","size","append","target","node","appendChild","get_root_for_style","document","root","getRootNode","ownerDocument","host","append_empty_stylesheet","style_element","element","style","head","sheet","append_stylesheet","insert","anchor","insertBefore","detach","parentNode","removeChild","destroy_each","iterations","detaching","i","length","d","name","createElement","text","data","createTextNode","space","listen","event","handler","options","addEventListener","removeEventListener","attr","attribute","value","removeAttribute","getAttribute","setAttribute","set_data","select_option","select","mounting","option","__value","selected","undefined","selectedIndex","managed_styles","Map","current_component","active","create_rule","duration","delay","ease","uid","step","keyframes","p","t","rule","str","hash","charCodeAt","doc","stylesheet","rules","get","info","set","create_style_information","insertRule","cssRules","animation","delete_rule","previous","split","next","filter","anim","indexOf","deleted","join","ownerNode","clear","set_current_component","component","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","add_render_callback","push","seen_callbacks","promise","flushidx","flush","saved_component","update","$$","e","pop","callback","has","add","fragment","before_update","dirty","ctx","after_update","dispatch","direction","kind","dispatchEvent","type","detail","bubbles","cancelable","createEvent","initCustomEvent","custom_event","outroing","outros","group_outros","r","check_outros","transition_in","block","local","transition_out","o","null_transition","create_bidirectional_transition","params","intro","config","running_program","pending_program","animation_name","clear_animation","init","program","Math","abs","start","end","group","go","easing","tick","css","fulfill","loop","then","create_component","mount_component","customElement","m","new_on_destroy","on_mount","map","on_destroy","destroy_component","filtered","targets","flush_render_callbacks","make_dirty","fill","instance","create_fragment","not_equal","props","append_styles","parent_component","bound","on_disconnect","context","callbacks","skip_bound","ready","ret","rest","hydrate","nodes","Array","from","childNodes","children","l","SvelteComponent","$destroy","this","$on","index","splice","$set","$$props","obj","$$set","keys","fade","linear","getComputedStyle","opacity","div","t1_value","key","t3_value","t1","t3","create_if_block_1","create_if_block","main","table","tr0","td0","td1","tr1","td2","td3","button","question","answer","date","model","sources","showSources","$$invalidate","t_value","answer_changes","each_value","label","each_blocks","modelDatePairs","startPair","selectedModel","selectedDate","slice","selectedPair","entry","func","call","h1","div0","div1","div2","g","replace","questions","models","selectedQuestion","values","groupedAnswers","q","flatMap","selected_option","querySelector","select_value","body"],"mappings":"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","x_google_ignoreList":[0,1]}